<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018学习清单]]></title>
    <url>%2F2018%2F11%2F29%2Ftimeline%2F</url>
    <content type="text"><![CDATA[业精于勤，荒于嬉；行成于思，毁于随。 2018年12期学习清单 STORM原理介绍及应用示例 FLINK原理介绍及应用示例 AKKA入门介绍 Pulsar &amp;&amp; Bookkeeper原理 搭建爬虫框架，爬取测试数据]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>timeline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA回顾】volatile关键字分析]]></title>
    <url>%2F2018%2F04%2F08%2Fvolatile%2F</url>
    <content type="text"><![CDATA[在 Java 并发编程中，要想使并发程序能够正确地执行，必须要保证三条原则，即：原子性、可见性和有序性。只要有一条原则没有被保证，就有可能会导致程序运行不正确。volatile 关键字 被用来保证可见性，即保证共享变量的内存可见性以解决缓存一致性问题。一旦一个共享变量被 volatile 关键字 修饰，那么就具备了两层语义：内存可见性和禁止进行指令重排序。在多线程环境下，volatile 关键字 主要用于及时感知共享变量的修改，并使得其他线程可以立即得到变量的最新值，例如，用于 修饰状态标记量 和 Double-Check (双重检查) 中。volatile 关键字 虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于 volatile 关键字 是与 内存模型 紧密相关，因此在讲述 volatile 关键字 之前，我们有必要先去了解与内存模型相关的概念和知识，然后回头再分析 volatile 关键字 的实现原理，最后在给出 volatile 关键字 的使用场景。 原文地址: https://blog.csdn.net/justloveyou_/article/details/53672005 一. 内存模型的相关概念 大家都知道，计算机在执行程序时，每条指令都是在 CPU 中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题：由于 CPU 执行速度很快，而从内存读取数据和向内存写入数据的过程跟 CPU 执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此，在 CPU 里面就有了 高速缓存（寄存器）。 也就是说，在程序运行过程中，会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中，那么， CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码： 1i = i + 1; 当线程执行这个语句时，会先从主存当中读取 i 的值，然后复制一份到高速缓存当中，然后 CPU 执行指令对 i 进行加 1 操作，然后将数据写入高速缓存，最后将高速缓存中 i 最新的值刷新到主存当中。 这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核 CPU 中，每个线程可能运行于不同的 CPU 中，因此每个线程运行时有自己的高速缓存（对单核 CPU 来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核 CPU 为例。 比如，同时有两个线程执行这段代码，假如初始时 i 的值为 0，那么我们希望两个线程执行完之后 i 的值变为 2。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取 i 的值存入各自所在的 CPU 的高速缓存当中，然后线程 1 进行加 1 操作，然后把 i 的最新值 1 写入到内存。此时线程 2 的高速缓存当中 i 的值还是 0，进行加 1 操作之后，i 的值为 1，然后线程 2 把 i 的值写入内存。 最终结果 i 的值是 1，而不是 2 。这就是著名的 缓存一致性问题 。通常称这种被多个线程访问的变量为 共享变量 。 也就是说，如果一个变量在多个 CPU 中都存在缓存（一般在多线程编程时才会出现），那么就可能存在 缓存不一致 的问题。 为了解决缓存不一致性问题，在 硬件层面 上通常来说有以下两种解决方法： 1）通过在 总线加 LOCK# 锁 的方式 （在软件层面，效果等价于使用 synchronized 关键字）； 2）通过 缓存一致性协议 （在软件层面，效果等价于使用 volatile 关键字）。 在早期的 CPU 当中，是通过在总线上加 LOCK# 锁的形式来解决缓存不一致的问题。因为 CPU 和其他部件进行通信都是通过总线来进行的，如果对总线加 LOCK# 锁的话，也就是说阻塞了其他 CPU 对其他部件访问（如内存），从而使得只能有一个 CPU 能使用这个变量的内存。比如上面例子中， 如果一个线程在执行 i = i + 1，如果在执行这段代码的过程中，在总线上发出了 LCOK# 锁的信号，那么只有等待这段代码完全执行完毕之后，其他 CPU 才能从变量 i 所在的内存读取变量，然后进行相应的操作，这样就解决了缓存不一致的问题。但是上面的方式会有一个问题，由于在锁住总线期间，其他 CPU 无法访问内存，导致效率低下。 所以，就出现了 缓存一致性协议 ，其中最出名的就是 Intel 的 MESI 协议。MESI 协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是： 当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态。因此，当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 二. 并发编程中的三个概念 在并发编程中，我们通常会遇到以下三个问题： 原子性问题 ， 可见性问题 和 有序性问题 。我们先看具体看一下这三个概念： 1、原子性 原子性： 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 一个很经典的例子就是银行账户转账问题： 比如从账户 A 向账户 B 转 1000 元，那么必然包括 2 个操作：从账户 A 减去 1000 元，往账户 B 加上 1000 元。 试想一下，如果这两个操作不具备原子性，会造成什么样的后果。假如从账户 A 减去 1000 元之后，操作突然中止。然后又从 B 取出了 500 元，取出 500 元之后，再执行 往账户 B 加上 1000 元 的操作。这样就会导致账户 A 虽然减去了 1000 元，但是账户 B 没有收到这个转过来的 1000 元。所以，这两个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地，反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下，假如为一个 32 位的变量赋值过程不具备原子性的话，会发生什么后果？ 1i = 9; 假若一个线程执行到这个语句时，我们暂且假设为一个 32 位的变量赋值包括两个过程：为低 16 位赋值，为高 16 位赋值。那么就可能发生一种情况：当将低 16 位数值写入之后，突然被中断，而此时又有一个线程去读取 i 的值，那么读取到的就是错误的数据，导致 数据不一致性 问题。 2、可见性 可见性： 是指当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 举个简单的例子，看下面这段代码： 123456//线程1执行的代码int i = 0;i = 10;//线程2执行的代码j = i; 假若执行 线程 1 的是 CPU1，执行 线程 2 的是 CPU2。由上面的分析可知，当 线程 1 执行 i = 10 这句时，会先把 i 的初始值加载到 CPU1 的高速缓存中，然后赋值为 10，那么在 CPU1 的高速缓存当中 i 的值变为 10 了，却没有立即写入到主存当中。此时，线程 2 执行 j = i，它会先去主存读取 i 的值并加载到 CPU2 的缓存当中，注意此时内存当中 i 的值还是 0，那么就会使得 j 的值为 0，而不是 10。 这就是可见性问题，线程 1 对变量 i 修改了之后，线程 2 没有立即看到 线程 1 修改后的值。 3、有序性 有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码： 1234int i = 0;boolean flag = false;i = 1; //语句1flag = true; //语句2 上面代码定义了一个 int 型 变量，定义了一个 boolean 型 变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句 1 是在 语句 2 前面的，那么 JVM 在真正执行这段代码的时候会保证 语句 1 一定会在 语句 2 前面执行吗？不一定，为什么呢？这里可能会发生 指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的（单线程情形下）。 比如上面的代码中，语句 1 和 语句 2 谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中， 语句 2 先执行而 语句 1 后执行。但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子： 1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4 这段代码有 4 个语句，那么可能的一个执行顺序是： 那么可不可能是这个执行顺序呢： 语句 2 -&gt; 语句 1 -&gt; 语句 4 -&gt; 语句 3 答案是不可能，因为处理器在进行重排序时会考虑指令之间的 数据依赖性，如果一个指令 Instruction 2 必须用到 Instruction 1 的结果，那么处理器会保证 Instruction 1 会在 Instruction 2 之前执行。 虽然 重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面，看一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2//线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 上面代码中，由于 语句 1 和 语句 2 没有数据依赖性，因此可能会被重排序。假如发生了重排序，在 线程 1 执行过程中先执行 语句 2，而此时 线程 2 会以为初始化工作已经完成，那么就会跳出 while 循环 ，去执行 doSomethingwithconfig(context) 方法，而此时 context 并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想使并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 三. Java 内存模型 在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下 Java 内存模型，研究一下 Java 内存模型 为我们提供了哪些保证以及在 Java 中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。 在 Java 虚拟机规范 中，试图定义一种 Java 内存模型（Java Memory Model，JMM） 来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。那么，Java 内存模型 规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java 内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在 Java 内存模型 中，也会存在缓存一致性问题和指令重排序的问题。 Java 内存模型 规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作，并且每个线程不能访问其他线程的工作内存。 举个简单的例子：在 java 中，执行下面这个语句： 1i = 10; 执行线程必须先在自己的工作线程中对 变量 i 所在的缓存进行赋值操作，然后再写入主存当中，而不是直接将数值 10 写入主存当中。那么，Java 语言本身对原子性、可见性以及有序性 提供了哪些保证呢？ 1、原子性 在 Java 中，对基本数据类型的变量的 读取 和 赋值 操作是原子性操作，即这些操作是不可被中断的 ： 要么执行，要么不执行。 上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子，请分析以下哪些操作是原子性操作： 1234x = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 乍一看，有些朋友可能会说上面的四个语句中的操作都是原子性操作。其实 只有 语句 1 是原子性操作，其他三个语句都不是原子性操作。 语句 1 是直接将数值 10 赋值给 x，也就是说线程执行这个语句的会直接将数值 10 写入到工作内存中； 语句 2 实际上包含两个操作，它先要去读取 x 的值，再将 x 的值写入工作内存。虽然，读取 x 的值以及 将 x 的值写入工作内存这两个操作都是原子性操作，但是合起来就不是原子性操作了； 同样的，x++ 和 x = x+1 包括 3 个操作：读取 x 的值，进行加 1 操作，写入新的值。 所以，上面四个语句只有 语句 1 的操作具备原子性。也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 不过，这里有一点需要注意：在 32 位平台下，对 64 位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的 JDK 中，JVM 已经保证对 64 位数据的读取和赋值也是原子性操作了。 从上面可以看出，Java 内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 2、可见性 对于可见性，Java 提供了 volatile 关键字 来保证可见性。 当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且 在释放锁之前会将对变量的修改刷新到主存当中，因此可以保证可见性。 3、有序性 在 Java 内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在 Java 中，可以通过 volatile 关键字来保证一定的 “有序性”（具体原理在下一节讲述）。另外，我们千万不能想当然地认为，可以通过 synchronized 和 Lock 来保证有序性，也就是说，不能由于 synchronized 和 Lock 可以让线程串行执行同步代码，就说它们可以保证指令不会发生重排序，这根本不是一个粒度的问题。 另外，Java 内存模型具备一些先天的 “有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从 happens-before 原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 下面就来具体介绍下 happens-before 原则（先行发生原则）： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作； 锁定规则：一个 unLock 操作先行发生于后面对同一个锁额 lock 操作； volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作； 传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C ； 线程启动规则：Thread 对象的 start() 方法先行发生于此线程的每个一个动作； 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生； 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行； 对象终结规则：一个对象的初始化完成先行发生于他的 finalize() 方法的开始。 这八条原则摘自《深入理解 Java 虚拟机》。这八条规则中，前四条规则是比较重要的，后四条规则都是显而易见的。下面我们来解释一下前四条规则： 对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到 “书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行 lock 操作。 第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现 happens-before 原则具备传递性。 四. 深入剖析 volatile 关键字1、volatile 关键字的两层语义一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰后，那么就具备了两层语义： 1）保证了不同线程对共享变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是 立即可见 的； 2）禁止进行指令重排序。 先看一段代码，假如 线程 1 先执行，线程 2 后执行： 12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125;//线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，如上图所示，每个线程在运行过程中都有自己的工作内存，那么 线程 1 在运行的时候，会将 stop 变量的值拷贝一份放在自己的工作内存当中。那么，当 线程 2 更改了 stop 变量 的值之后，可能会出现以下两种情形： 线程 2 对变量的修改没有立即刷入到主存当中； 即使 线程 2 对变量的修改立即反映到主存中，线程 1 也可能由于没有立即知道 线程 2 对 stop 变量的更新而一直循环下去。 这两种情形都会导致 线程 1 处于死循环。但是，用 volatile 关键字 修饰后就变得不一样了，如下图所示： ① 使用 volatile 关键字会强制将修改的值立即写入主存; ② 使用 volatile 关键字的话，当 线程 2 进行修改时，会导致 线程 1 的工作内存中缓存变量 stop 的缓存行无效（反映到硬件层的话，就是 CPU 的 L1 或者 L2 缓存中对应的缓存行无效）； ③ 由于 线程 1 的工作内存中缓存变量 stop 的缓存行无效，所以，线程 1 再次读取变量 stop 的值时会去主存读取。 综上，在 线程 2 修改 stop 值时（当然这里包括两个操作，修改 线程 2 工作内存中的值，然后将修改后的值写入内存），会使得 线程 1 的工作内存中缓存变量 stop 的缓存行无效，然后 线程 1 读取时，会发现自己的缓存行无效从而去对应的主存读取最新的值 。简化一下，通过使用 volatile 关键字，如下图所示，线程会及时将变量的新值更新到主存中，并且保证其他线程能够立即读到该值。这样，线程 1 读取到的就是最新的、正确的值。 下面通过两个例子更好地了解关键字 volatile 的作用。下面先看 示例 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//资源类class MyList &#123; // 临界资源 private List list = new ArrayList(); // 对临界资源的访问 public void add() &#123; list.add("rico"); &#125; public int size() &#123; return list.size(); &#125;&#125;// 线程Bclass ThreadB extends Thread &#123; private MyList list; public ThreadB(MyList list) &#123; super(); this.list = list; &#125; @Override public void run() &#123; // 任务 B try &#123; while (true) &#123; if (list.size() == 2) &#123; System.out.println("list中的元素个数为2了，线程b要退出了！"); throw new InterruptedException(); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;// 线程Aclass ThreadA extends Thread &#123; private MyList list; public ThreadA(MyList list) &#123; super(); this.list = list; &#125; @Override public void run() &#123; // 任务 A try &#123; for (int i = 0; i &lt; 3; i++) &#123; list.add(); System.out.println("添加了" + (i + 1) + "个元素"); Thread.sleep(1000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;// 测试public class Test &#123; public static void main(String[] args) &#123; MyList service = new MyList(); ThreadA a = new ThreadA(service); a.setName("A"); a.start(); ThreadB b = new ThreadB(service); b.setName("B"); b.start(); &#125;&#125; 运行结果如下所示： 第一个运行结果是在没有使用 volatile 关键字的情况下产生的，第二个运行结果是在使用 volatile 关键字的情况下产生的。 特别地，博友 qq_27571221(王小军 08) 提到， “若将 类 ThreadA 中的 run() 方法中的 Thread.sleep(1000); 去掉，上述两种运行结果都有可能出现。” 事实上，之所以会出现这种情况，究其根本，是由线程获得 CPU 执行的不确定性引起的。也就是说，在使用 volatile 关键字修饰共享变量 list 的前提下，去掉代码 Thread.sleep(1000); 后，之所以也会出现第一种运行结果是因为存在这样一种情形：线程 A 早已运行结束但线程 B 才刚刚开始执行或尚未开始执行，即串行执行的情形。总的来说，在类 ThreadA 中的 run() 方法中添加 Thread.sleep(1000); 的原因就是 **为了保证线程 A、B 能交替执行，防止上述情形的出现。 示例 2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestVolatile &#123; public static void main(String[] args) &#123; ThreadDemo td = new ThreadDemo(); new Thread(td, "ThreadDemo").start(); while (true) &#123; // 加上下面三句代码的任意一句，程序都会正常结束： // System.out.println("!!"); //...语句1 // synchronized (TestVolite.class) &#123;&#125; //...语句2 //TestVolite.test2(); //...语句3 // 若只加上下面一句代码，程序都会死循环： // TestVolite.test1(); //...语句4 if (td.flag) &#123; System.out.println("线程 " + Thread.currentThread().getName() + " 即将跳出while循环体... "); break; &#125; &#125; &#125; public static void test1() &#123;&#125; public synchronized static void test2() &#123;&#125;&#125;class ThreadDemo implements Runnable &#123; public boolean flag = false; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; flag = true; System.out.println("线程 " + Thread.currentThread().getName() + " 执行完毕： " + "置 flag= " + flag + " ..."); &#125;&#125; 上述程序运行结果如下图： 下面对该程序分以下 5 种情形进行修改并讨论，如下所示 ： Case 1：只用 volatile 关键字修饰 类 ThreadDemo 中的共享变量 flag 运行结果为： Case 2：只取消对语句 1 的注释 运行结果为： Case 3：只取消对语句 2 的注释 运行结果为： Case 4：只取消对语句 3 的注释运行结果为： Case 5：只取消对语句 4 的注释运行结果为： 关于上面五种情形，情形 1 和 情形 5 很容易理解，此不赘述。 但是，对于上面的 第 2、3、4 三种情形，可能有很多朋友就不能理解了，特别是 第 2 种情形。其实，这三种情形都反映了一个问题：在我们不使用 volatile 关键字修饰共享变量去保证其可见性时，那么线程是不是始终一直从自己的工作内存中读取变量的值呢？ 什么情况下，线程工作内存中的变量值才会与主存中的同步并取得一致状态呢？ 事实上，除了 volatile 可以保证内存可见性外，synchronized 也可以保证可见性，因为每次运行 synchronized 块 或者 synchronized 方法都会导致线程工作内存与主存的同步，使得其他线程可以取得共享变量的最新值。也就是说，synchronized 语义范围不但包括 volatile 具有的可见性，也包括原子性，但不能禁止指令重排序，这是二者一个功能上的差异。说到这里，朋友应该就理解了 情形 3 和 情形 4 了。但是，情形 2 怎么也会导致类似于 情形 3 和 情形 4 的效果呢？ 因为 System.out.println() 方法里面包含 synchronized 块， 我们看完它的源码就大彻大悟了，如下： 123456public void println(String x) &#123; synchronized (this) &#123; // synchronized 块 print(x); newLine(); &#125;&#125; 在此，特别感谢 CSDN 博友 Geek-k(u010395144) 所提出的问题，是他的提问，我才能更好的诠释这个问题，更好的提升自己，更好的帮助更多的朋友。更多关于 synchronized 关键字 的介绍请移步我的另一篇博文《Java 并发：内置锁 Synchronized》。更多关于 Java 多线程 方面的知识请移步我的专栏《Java 并发编程学习笔记》。 2、volatile 保证原子性吗？ 从上面知道， volatile 关键字保证了操作的可见性，但是 volatile 能保证对变量的操作是原子性吗？ 下面看一个例子：1234567891011121314151617181920212223242526272829303132333435//线程类class MyThread extends Thread &#123; // volatile 共享静态变量，类成员 public volatile static int count; private static void addCount() &#123; for (int i = 0; i &lt; 100; i++) &#123; count++; &#125; System.out.println("count=" + count); &#125; @Override public void run() &#123; addCount(); &#125;&#125;//测试类public class Run &#123; public static void main(String[] args) &#123; //创建 100个线程并启动 MyThread[] mythreadArray = new MyThread[100]; for (int i = 0; i &lt; 100; i++) &#123; mythreadArray[i] = new MyThread(); &#125; for (int i = 0; i &lt; 100; i++) &#123; mythreadArray[i].start(); &#125; &#125;&#125;/* Output(循环): ... ... count=9835 *///:~ 大家想一下这段程序的输出结果是多少？也许有些朋友认为是 10000。但是事实上运行它会发现每次运行结果都不一致，都是一个 小于 10000 的数字。可能有的朋友就会有疑问，不对啊，上面是对变量 count 进行自增操作，由于 volatile 保证了可见性，那么在每个线程中对 count 自增完之后，在其他线程中都能看到修改后的值啊，所以有 100 个 线程分别进行了 100 次操作，那么最终 count 的值应该是 100*100=10000。 这里面就有一个误区了，volatile 关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是 volatile 没办法保证对变量的操作的原子性。在前面已经提到过，自增操作是不具备原子性的，它包括 读取变量的原始值、进行加 1 操作 和 写入工作内存 三个原子操作。那么就是说，这三个子操作可能会分割开执行，所以就有可能导致下面这种情况出现： 假如某个时刻 变量 count 的值为 10，线程 1 对变量进行自增操作，线程 1 先读取了 变量 count 的原始值，然后 线程 1 被阻塞了；然后，线程 2 对变量进行自增操作，线程 2 也去读取 变量 count 的原始值，由于 线程 1 只是对 变量 count 进行读取操作，而没有对变量进行修改操作，所以不会导致 线程 2 的工作内存中缓存变量 count 的缓存行无效，所以 线程 2 会直接去主存读取 count 的值 ，发现 count 的值是 10，然后进行加 1 操作。注意，此时 线程 2 只是执行了 count + 1 操作，还没将其值写到 线程 2 的工作内存中去！此时线程 2 被阻塞，线程 1 进行加 1 操作时，注意操作数 count 仍然是 10！然后，线程 2 把 11 写入工作内存并刷到主内存。虽然此时 线程 1 能感受到 线程 2 对 count 的修改，但由于线程 1 只剩下对 count 的写操作了，而不必对 count 进行读操作了，所以此时 线程 2 对 count 的修改并不能影响到 线程 1。于是，线程 1 也将 11 写入工作内存并刷到主内存。也就是说，两个线程分别进行了一次自增操作后，count 只增加了 1。下图演示了这种情形： 进一步地，将上述代码修改成下面示例的样子以后，这个问题就迎刃而解： 12345678910111213141516171819202122232425262728293031323334//线程类class MyThread extends Thread &#123; // 既然使用 synchronized关键字 ，就没必要使用 volatile关键字了 public static int count; //注意必须添加 static 关键字，这样synchronized 与 static 锁的就是 Mythread.class 对象了， //也就达到同步效果了 private synchronized static void addCount() &#123; for (int i = 0; i &lt; 100; i++) &#123; count++; &#125; System.out.println("count=" + count); &#125; @Override public void run() &#123; addCount(); &#125;&#125;//测试类public class Run &#123; public static void main(String[] args) &#123; //创建 100个线程并启动 MyThread[] mythreadArray = new MyThread[100]; for (int i = 0; i &lt; 100; i++) &#123; mythreadArray[i] = new MyThread(); &#125; for (int i = 0; i &lt; 100; i++) &#123; mythreadArray[i].start(); &#125; &#125;&#125; 使用 Lock 和 Java 1.5 所提供的 java.util.concurrent.atomic 包来保证线程安全性将在后面的博文中进行介绍。 五. 使用 volatile 关键字的场景synchronized 关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率；而 volatile 关键字在某些情况下性能要优于 synchronized，但是要注意 volatile 关键字是无法替代 synchronized 关键字的，因为 volatile 关键字无法保证操作的原子性。通常来说，使用 volatile 必须具备以下两个条件： 1）对变量的写操作不依赖于当前值；2）该变量没有包含在具有其他变量的不变式中。 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值 独立于任何程序的状态，包括变量的当前状态。事实上，上面的两个条件就是保证对 该 volatile 变量 的操作是原子操作，这样才能保证使用 volatile 关键字 的程序在并发时能够正确执行。 特别地，关键字 volatile 主要使用的场合是: 在多线程环境下及时感知共享变量的修改，并使得其他线程可以立即得到变量的最新值。 1、状态标记量12345678910// 示例 1volatile boolean flag = false;while(!flag)&#123; doSomething();&#125;public void setFlag() &#123; flag = true;&#125; 123456789101112// 示例 2volatile boolean inited = false;//线程1:context = loadContext();inited = true;//线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 更多关于 volatile 在状态标记量方面的应用，请移步我的博文《Java 并发：线程间通信与协作》。 2、Double-Check (双重检查) 1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 更多关于 Double-Check (双重检查) 的定义与应用场景 的介绍，请移步我的博文《彻头彻尾理解单例模式与多线程》。 六. 小结关键字 volatile 与内存模型紧密相关，是线程同步的轻量级实现，其性能要比 synchronized 关键字 好。在作用对象和作用范围上， volatile 用于修饰变量，而 synchronized 关键字 用于修饰方法和代码块，而且 synchronized 语义范围不但包括 volatile 拥有的可见性，还包括 volatile 所不具有的原子性，但不包括 volatile 拥有的有序性，即允许指令重排序。因此，在多线程环境下，volatile 关键字 主要用于及时感知共享变量的修改，并保证其他线程可以及时得到变量的最新值。可用以下文氏图表示 synchronized 和 volatile 语义范围：]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA回顾】匿名内部类]]></title>
    <url>%2F2018%2F04%2F07%2Fanonymous-inner-class%2F</url>
    <content type="text"><![CDATA[匿名内部类用法 使用匿名内部内部类匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下： 1234new 父类构造器（参数列表）|实现接口（）&#123; //匿名内部类的类体部分&#125; 在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引用。当然这个引用是隐式的。 12345678910111213141516171819202122232425262728293031323334353637public abstract class Bird &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public abstract int fly();&#125;public class Test &#123; public void test(Bird bird)&#123; System.out.println(bird.getName() + "能够飞 " + bird.fly() + "米"); &#125; public static void main(String[] args) &#123; Test test = new Test(); test.test(new Bird() &#123; public int fly() &#123; return 10000; &#125; public String getName() &#123; return "大雁"; &#125; &#125;); &#125;&#125;------------------Output：大雁能够飞 10000米 在 Test 类中，test() 方法接受一个 Bird 类型的参数，同时我们知道一个抽象类是没有办法直接 new 的，我们必须要先有实现类才能 new 出来它的实现类实例。所以在 mian 方法中直接使用匿名内部类来创建一个 Bird 实例。由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。对于这段匿名内部类代码其实是可以拆分为如下形式： 123456789101112public class WildGoose extends Bird&#123; public int fly() &#123; return 10000; &#125; public String getName() &#123; return "大雁"; &#125;&#125;WildGoose wildGoose = new WildGoose();test.test(wildGoose); 在这里系统会创建一个继承自 Bird 类的匿名类的对象，该对象转型为对 Bird 类型的引用。对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对 test() 方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。 注意事项在使用匿名内部类的过程中，我们需要注意如下几点： 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口 匿名内部类中是不能定义构造函数的 匿名内部类中不能存在任何的静态成员变量和静态方法 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法 使用的形参为何要为 final我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为 final。也就是说：当所在的方法的形参需要被内部类里面使用时，该形参必须为 final。为什么必须要为 final 呢？首先我们知道在内部类编译成功后，它会产生一个 class 文件，该 class 文件与外部类并不是同一 class 文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从 java 程序的角度来看是直接被调用： 123456789public class OuterClass &#123; public void display(final String name,String age)&#123; class InnerClass&#123; void display()&#123; System.out.println(name); &#125; &#125; &#125;&#125; 从上面代码中看好像 name 参数应该是被内部类直接调用？其实不然，在 java 编译之后实际的操作如下： 12345678910public class OuterClass$InnerClass &#123; public InnerClass(String name,String age)&#123; this.InnerClass$name = name; this.InnerClass$age = age; &#125; public void display()&#123; System.out.println(this.InnerClass$name + "----" + this.InnerClass$age ); &#125;&#125; 所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。直到这里还没有解释为什么是 final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变。 简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用 final 来让该引用不可改变。 故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是 final 的。 匿名内部类初始化我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。 1234567891011121314151617181920212223242526272829303132public class OutClass &#123; public InnerClass getInnerClass(final int age,final String name)&#123; return new InnerClass() &#123; int age_ ; String name_; //构造代码块完成初始化工作 &#123; if(0 &lt; age &amp;&amp; age &lt; 200)&#123; age_ = age; name_ = name; &#125; &#125; public String getName() &#123; return name_; &#125; public int getAge() &#123; return age_; &#125; &#125;; &#125; public static void main(String[] args) &#123; OutClass out = new OutClass(); InnerClass inner_1 = out.getInnerClass(201, "chenssy"); System.out.println(inner_1.getName()); InnerClass inner_2 = out.getInnerClass(23, "chenssy"); System.out.println(inner_2.getName()); &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA回顾】final关键字用法]]></title>
    <url>%2F2018%2F04%2F07%2Fjava-final%2F</url>
    <content type="text"><![CDATA[FINAL关键字用法&amp;总结 final 是 Java 中非常常见的一个关键字，可以说每天都在使用它，虽然常见，但却也不见得都那么显而易见，今天就来研究一下 final，以加深对它的理解和更合理的运用。 修饰类当一个类不想被继承时，就可以用 final 来修饰。 修饰方法当一个方法不想被子类覆写 (Override) 时，可以用 final 来修饰。另外一方面，把方法用 final 来修饰也有一定的性能提升上的帮助，因为虚拟机知道它不会被覆写，所以可以以更简单的方式来处理。private 的方法，默认都会被编译器加上 final. 修饰变量被 final 修饰的变量只能赋值一次，之后不能再被修改。如：12final int a = 10;a = 4; // compilation error 需要注意的是，这里说的是只能赋值一次，并不意味着，非要在声明变量时直接初始化，比如，下面的代码也是完全合法的：123456final int a;if (foo()) &#123; a = 3;&#125; else &#123; a = 4;&#125; 修饰域变量域变量也是变量，所以用 final 来修饰的第一个作用就是赋值后，不能再修改变量的值，比如:12final int a = 10;final Object b = new Object(); 对于基本类型来说，就是变量值不能再被修改；对于引用来说，就是不能再让其指向其他对象或者 null。但对于域变量，声明为 final 的域变量必须在声明时初始化，或者在构造方法中初始化，否则会有编译错误。此外，声明为 final 的域变量还有内存模型上的语义，下面详细说 防止变量从构造方法中逸出(内存模型的作用)这个主要是针对被 final 修饰的域变量，虚拟机会有禁止指令重排的保证： 在构造方法内对一个 final 变量的写入，与随后这个被构造对象的引用赋值给一个引用变量，这二个顺序不改变，final 变量的写入一定要早于对象引用的赋值。什么意思呢？在多线程环境下，域变量是有可能从构造方法中逸出的，也就是说线程有可能读到还没有被构造方法初始化的域变量的值。比如：1234567class Foo &#123; int a; Foo(int v) &#123; a = v; &#125;&#125; 如果是在多线程环境下，一个线程 A 在创建 Foo 的对象，另一个线程 B 在读对象的 a 的值，则 B 是有可能读到未正确初始化 a 的值（默认初始值 0）。这就是域变量从构造方法中逸出。关键字 final 可以禁止虚拟机指令重排，从而保证了构造方法执行完毕前 final 修饰的变量一定是初始化过了的。这部分可以参考深入理解 Java 内存模型（六）——final，讲解的非常详细。 匿名内部类使用外部变量时为何要强制使用 final 修饰这个大家肯定都习以为常了，比如：1234567891011private void initViews() &#123; final int a = 3; // Compilation error if remove final btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (a &gt; 1) &#123; // volala &#125; &#125; &#125;&#125; 那么，有没有想过为什么？而像其他支持完整闭包的语言如 JavaScript，Python 等，是没有这等限制的。究其原因，是 Java 对闭包支持不够完整，或者说它并不是像动态语言那样的完整闭包。对于匿名内部类来说，编译器会创建一个命名类 (OutClass$1 之类的)，然后把匿名类所在的能捕获的变量)，以构造参数的形式传递给内部类使用，这样一样，外部的变量与内部类看到的变量是不同的，虽然它们的值是相同的，因此，如果再允许外部修改这些变量，或者内部类里面修改这些变量，都会造成数据的不一致性（因为它们是不同的变量），所以 Java 强制要求匿名内部类访问的外部变量要加上 final 来修饰。对于其他语言，匿名内部类，持有的是外部变量的一个包装的引用 (wrapper reference)，这可以能看不懂，但是理解起来就是内部类能直接访问外部变量，外部与闭包内部访问的是同一个变量，因此外部修改了，内部能看到变化，内部修改了，外部也能看到变化。一句话总结就是，Java 内部类与外部持有的是值相同的不同的变量；其他支持闭包的语言则持有的是相同的变量。 建议能使用 final 的地方就加上 final 修饰最后来聊聊，啥时候应该用 final 呢？孤的建议 (以及众多大师的建议) 就是能多用就多用，除非不能用 final，否则就用。原因，有这么几条： 域变量尽可能加上 final这个原因比较明确，前面也提到了，在多线程条件下，会有很大的优势。尽可能加上 final 来修饰域变量，甚至用 Immutable Object，可以省去构造时的多线程同步。多线程最大的麻烦是状态同步，啥是状态？其实就是共享数据，域变量就是共享数据，所以，如果共享数据都是不可变的 (Immutable)，那么自然就没有了同步上的麻烦。 final 类和方法能提升性能正常的类和方法，虚拟机需要为了继承和方法覆写而做一次准备，如果加上了 final，虚拟机知道它不会被继承或者覆写，那么就可以做一些优化。虽然，这并不显著，但是还是可以提升一些性能的。 final 变量能提升可读性无论是域变量还是本地变量，加上了 final 修饰，程序的维护者就知道了，这个变量的值不会再改变，这无疑会大大增加可读性。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA回顾】STATIC关键字]]></title>
    <url>%2F2018%2F04%2F07%2Fjava-static%2F</url>
    <content type="text"><![CDATA[STATIC关键字用法&amp;总结 初识 staticstatic 是 “静态” 的意思，这个大家应该都清楚，静态变量，静态方法大家也都能随口道来。但是，你真的理解静态变量和静态方法么？除了这些 static 还有什么用处？ 事实上，static 大体上有五种用法： 静态导入 静态变量 静态方法 静态代码段 静态内部类 接下来，我们将逐个看一下这些用法。 静态导入也许有的人是第一次听说静态导入，反正我在写这篇文章之前是不清楚 static 还可以这样用的。什么是静态导入呢？我们先来看一段代码： 12345678910public class OldImport &#123; public static void main(String[] args) &#123; double a = Math.cos(Math.PI / 2); double b = Math.pow(2.4,1.2); double r = Math.max(a,b); System.out.println(r); &#125;&#125; 看到这段代码，你有什么想说的么？啥？没有？你不觉得 Math 出现的次数太多了么？ 恩，你觉得好像是有点多，怎么办呢？看下面： 123456789101112import static java.lang.Math.*;public class StaticImport &#123; public static void main(String[] args) &#123; double a = cos(PI / 2); double b = pow(2.4,1.2); double r = max(a,b); System.out.println(r); &#125;&#125; 这就是静态导入。我们平时使用一个静态方法的时候，都是【类名. 方法名】，使用静态变量的时候都是【类名. 变量名】，如果一段代码中频繁的用到了这个类的方法或者变量，我们就要写好多次类名，比如上面的 Math，这显然不是喜欢偷懒的程序员所希望做的，所以出现了静态导入的功能。 静态导入，就是把一个静态变量或者静态方法一次性导入，导入后可以直接使用该方法或者变量，而不再需要写对象名。 怎么样，是不是觉得很方便？如果你以前不知道这个，你大概在窃喜，以后可以偷懒了。先别高兴的太早，看下面的代码： 123456789101112131415161718import static java.lang.Double.*;import static java.lang.Integer.*;import static java.lang.Math.*;import static java.text.NumberFormat.*;public class ErrorStaticImport &#123; // 输入半径和精度要求，计算面积 public static void main(String[] args) &#123; double s = PI * parseDouble(args[0]); NumberFormat nf = getInstance(); nf.setMaximumFractionDigits(parseInt(args[1])); formatMessage(nf.format(s)); &#125; // 格式化消息输出 public static void formatMessage(String s)&#123; System.out.println(&quot; 圆面积是：&quot;+s); &#125;&#125; 就这么一段程序，看着就让人火大：常量 PI，这知道，是圆周率；parseDouble 方法可能是 Double 类的一个转换方法，这看名称也能猜测到。那紧接着的 getInstance 方法是哪个类的？是 ErrorStaticImport 本地类的方法？不对呀，没有这个方法，哦，原来是 NumberFormate 类的方法，这和 formateMessage 本地方法没有任何区别了。这代码也太难阅读了，这才几行？要是你以后接别人的代码，看到成千上万行这种代码大概你想死的心都有了吧？ 所以，不要滥用静态导入！！！不要滥用静态导入！！！不要滥用静态导入！！！ 正确使用静态导入的姿势是什么样子的呢？ 1234567891011121314151617181920import java.text.NumberFormat;import static java.lang.Double.parseDouble;import static java.lang.Integer.parseInt;import static java.lang.Math.PI;import static java.text.NumberFormat.getInstance;public class ErrorStaticImport &#123; // 输入半径和精度要求，计算面积 public static void main(String[] args) &#123; double s = PI * parseDouble(args[0]); NumberFormat nf = getInstance(); nf.setMaximumFractionDigits(parseInt(args[1])); formatMessage(nf.format(s)); &#125; // 格式化消息输出 public static void formatMessage(String s)&#123; System.out.println(&quot; 圆面积是：&quot;+s); &#125;&#125; 没错，这才是正确的姿势，你使用哪个方法或者哪个变量，就把他导入进来，而不要使用通配符（*）！ 并且，由于不用写类名了，所以难免会和本地方法混淆。所以，本地方法在起名字的时候，一定要起得有意义，让人一看这个方法名大概就能知道你这个方法是干什么的，而不是什么 method1(),method2()，鬼知道你写的是什么。。 总结： 不使用 * 通配符，除非是导入静态常量类（只包含常量的类或接口）。 方法名是具有明确、清晰表象意义的工具类。 这里有一个小插曲，就是我在用 idea 写示例代码的时候，想用通配符做静态导入，结果刚写完，idea 自动给我改成非通配符的了，嘿我这暴脾气，我再改成通配符！特喵的。。又给我改回去了。。。事实证明，用一个好的 IDE，是可以提高效率，比呢且优化好你的代码的，有的时候后，想不优化都不行。哈哈哈，推荐大家使用 idea。 静态变量 这个想必大家都已经很熟悉了。我就再啰嗦几句。 java 类提供了两种类型的变量：用 static 修饰的静态变量和不用 static 修饰的成员变量。 静态变量属于类，在内存中只有一个实例。当 jtbl 所在的类被加载的时候，就会为该静态变量分配内存空间，该变量就可以被使用。jtbl 有两种被使用方式：【类名. 变量名】和【对象. 变量名】。 实例变量属于对象，只有对象被创建后，实例对象才会被分配空间，才能被使用。他在内存中存在多个实例，只能通过【对象. 变量名】来使用。 java 的内存大体上有四块：堆，栈，静态区，常量区。其中的静态区，就是用来放置静态变量的。当静态变量的类被加载时，虚拟机就会在静态区为该变量开辟一块空间。所有使用该静态变量的对象都访问这一个空间。 一个例子学习静态变量与实例变量。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class StaticAttribute &#123; public static int staticInt = 10; public static int staticIntNo ; public int nonStatic = 5; public static void main(String[] args) &#123; StaticAttribute s = new StaticAttribute(); System.out.println(&quot;s.staticInt= &quot; + s.staticInt); System.out.println(&quot;StaticAttribute.staticInt= &quot; + StaticAttribute.staticInt); System.out.println(&quot;s.staticIntNo= &quot; + s.staticIntNo); System.out.println(&quot;StaticAttribute.staticIntNo= &quot; + StaticAttribute.staticIntNo); System.out.println(&quot;s.nonStatic= &quot; + s.nonStatic); System.out.println(&quot;使用s,让三个变量都+1&quot;); s.staticInt ++; s.staticIntNo ++; s.nonStatic ++; StaticAttribute s2 = new StaticAttribute(); System.out.println(&quot;s2.staticInt= &quot; + s2.staticInt); System.out.println(&quot;StaticAttribute.staticInt= &quot; + StaticAttribute.staticInt); System.out.println(&quot;s2.staticIntNo= &quot; + s2.staticIntNo); System.out.println(&quot;StaticAttribute.staticIntNo= &quot; + StaticAttribute.staticIntNo); System.out.println(&quot;s2.nonStatic= &quot; + s2.nonStatic); &#125;&#125;// 结果：// s.staticInt= 10// StaticAttribute.staticInt= 10// s.staticIntNo= 0// StaticAttribute.staticIntNo= 0// s.nonStatic= 5// 使用s,让三个变量都+1// s2.staticInt= 11// StaticAttribute.staticInt= 11// s2.staticIntNo= 1// StaticAttribute.staticIntNo= 1// s2.nonStatic= 5 从上例可以看出，静态变量只有一个，被类拥有，所有对象都共享这个静态变量，而实例对象是与具体对象相关的。 与 c++ 不同的是，在 java 中，不能在方法体中定义 static 变量，我们之前所说的变量，都是类变量，不包括方法内部的变量。 那么，静态变量有什么用途呢？ 静态变量的用法最开始的代码中有一个静态变量 — PI，也就是圆周率。为什么要把它设计为静态的呢？因为我们可能在程序的任何地方使用到这个变量，如果不是静态的，那么我们每次使用这个变量的时候都要创建一个 Math 对象，不仅代码臃肿而且浪费了内存空间。 所以，当你的某一个变量会经常被外部代码访问的时候，可以考虑设计为静态的。 静态方法 同样，静态方法大家应该也比较熟悉了。就是在定义类的时候加一个 static 修饰符。 与静态变量一样，java 类也同时提供了 static 方法和非 static 方法。 static 方法是类的方法，不需要创建对象就可以使用，比如 Math 类里面的方法。使用方法【对象. 方法名】或者【类名. 方法名】 非 static 方法是对象的方法，只有对象呗创建出来以后才可以被使用。使用方法【对象. 方法名】 static 怎么用代码写我想大家都知道，这里我就不举例了，你们看着烦，我写着也烦。 注意事项static 方法中不能使用 this 和 super 关键字，不能调用非 static 方法，只能访问所属类的静态变量和静态方法。因为当 static 方法被调用的时候，这个类的对象可能还没有创建，即使已经被创建了，也无法确认调用那个对象的方法。不能访问非静态方法同理。 用途—单例模式static 的一个很常见的用途是实现单例模式。单例模式的特点是一个类只能有一个实例，为了实现这一功能，必须隐藏该类的构造函数，即把构造函数声明为 private，并提供一个创建对象的方法。我们来看一下怎么实现： 1234567891011121314public class Singleton &#123; private static Singleton singleton; public static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125; private Singleton() &#123; &#125;&#125; 这个类，只会有一个对象。 其他用 public 修饰的 static 成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成 static 变量的副本，而是类的所有实例共享同一个 static 变量。 static 变量前可以有 private 修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用–废话），但是不能在其他类中通过类名来直接引用，这一点很重要。 实际上你需要搞明白，private 是访问权限限定，static 表示不要实例化就可以使用，这样就容易理解多了。static 前面加上其它访问权限关键字的效果也以此类推。 静态方法的用场静态变量可以被非静态方法调用，也可以被静态方法调用。但是静态方法只能被静态方法调用。 一般工具方法会设计为静态方法，比如 Math 类中的所有方法都是惊天的，因为我们不需要 Math 类的实例，我们只是想要用一下里面的方法。所以，你可以写一个通用的 工具类，然后里面的方法都写成静态的。 静态代码块在讲静态代码块之前，我们先来看一下，什么是代码块。 什么是代码块所谓代码块就是用大括号将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在 Java 中代码块主要分为四种：普通代码块，静态代码块，同步代码块和构造代码块。 四种代码块 普通代码块 普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用 {} 括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。 123public void common()&#123; System.out.println(&quot;普通代码块执行&quot;);&#125; 静态代码块 静态代码块就是用 static 修饰的用 {} 括起来的代码段，它的主要目的就是对静态属性进行初始化。 静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM 加载类时会执行这些静态的代码块，如果 static 代码块有多个，JVM 将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 看一段代码： 12345678910111213public class Person&#123; private Date birthDate; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; Date startDate = Date.valueOf(&quot;1990&quot;); Date endDate = Date.valueOf(&quot;1999&quot;); return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; isBornBoomer 是用来这个人是否是 1990-1999 年出生的，而每次 isBornBoomer 被调用的时候，都会生成 startDate 和 birthDate 两个对象，造成了空间浪费，如果改成这样效率会更好： 12345678910111213141516public class Person&#123; private Date birthDate; private static Date startDate,endDate; static&#123; startDate = Date.valueOf(&quot;1990&quot;); endDate = Date.valueOf(&quot;1999&quot;); &#125; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; 因此，很多时候会将一些只需要进行一次的初始化操作都放在 static 代码块中进行。 同步代码块 使用 synchronized 关键字修饰，并使用 “{}” 括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。 构造代码块 在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？ 看一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class CodeBlock &#123; private int a = 1; private int b ; private int c ; //静态代码块 static &#123; int a = 4; System.out.println(&quot;我是静态代码块1&quot;); &#125; //构造代码块 &#123; int a = 0; b = 2; System.out.println(&quot;构造代码块1&quot;); &#125; public CodeBlock()&#123; this.c = 3; System.out.println(&quot;构造函数&quot;); &#125; public int add()&#123; System.out.println(&quot;count a + b + c&quot;); return a + b + c; &#125; //静态代码块 static &#123; System.out.println(&quot;我是静态代码块2，我什么也不做&quot;); &#125; //构造代码块 &#123; System.out.println(&quot;构造代码块2&quot;); &#125; public static void main(String[] args) &#123; CodeBlock c = new CodeBlock(); System.out.println(c.add()); System.out.println(); System.out.println(&quot;*******再来一次*********&quot;); System.out.println(); CodeBlock c1 = new CodeBlock(); System.out.println(c1.add()); &#125;&#125;//结果：//我是静态代码块1//我是静态代码块2，我什么也不做//构造代码块1//构造代码块2//构造函数//count a + b + c//6////*******再来一次*********////构造代码块1//构造代码块2//构造函数//count a + b + c//6 这段代码综合了构造代码块，普通代码块和静态代码块。我们来总结一下： 静态代码块只会执行一次。有多个静态代码块时按顺序依次执行。 构造代码块每次创建新对象时都会执行。有多个时依次执行。 执行顺序：静态代码块 &gt; 构造代码块 &gt; 构造函数。 构造代码块和静态代码块有自己的作用域，作用域内部的变量不影响作用域外部。 构造代码块的应用场景： 1、 初始化实例变量如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。 2、 初始化实例环境一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。 静态内部类被 static 修饰的内部类，它可以不依赖于外部类实例对象而被实例化，而通常的内部类需要在外部类实例化后才能实例化。静态内部类不能与外部类有相同的名字，不能访问外部类的普通成员变量，只能访问内部类中的静态成员和静态方法（包括私有类型）。 由于还没有详细讲解过内部类，这里先一笔带过，在讲解内部类的时候会详细分析静态内部类。 只有内部类才能被 static 修饰，普通的类不可以。 总结本文内容就先到这里，我们再来回顾一下学了什么： static 关键字的五种用法： 静态导入 静态变量 静态方法 静态代码块 静态内部类 代码块 普通代码块 静态代码块 构造代码块 同步代码块 回忆一下这些知识点的内容，如果想不起来，记得翻上去再看一遍~ 彩蛋 —— 继承 + 代码块的执行顺序如果既有继承，又有代码块，执行的顺序是怎样呢？ 12345678910111213141516171819202122232425262728293031323334353637public class Parent &#123; static &#123; System.out.println(&quot;父类静态代码块&quot;); &#125; &#123; System.out.println(&quot;父类构造代码块&quot;); &#125; public Parent()&#123; System.out.println(&quot;父类构造函数&quot;); &#125;&#125;class Children extends Parent &#123; static &#123; System.out.println(&quot;子类静态代码块&quot;); &#125; &#123; System.out.println(&quot;子类构造代码块&quot;); &#125; public Children()&#123; System.out.println(&quot;子类构造函数&quot;); &#125; public static void main(String[] args) &#123; new Children(); &#125;&#125;//结果：//父类静态代码块//子类静态代码块//父类构造代码块//父类构造函数//子类构造代码块//子类构造函数 结果你也知道了： 先执行静态内容 (先父类后子类)，然后执行父类非静态，最后执行子类非静态。（非静态包括构造代码块和构造函数，构造代码块先执行）]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch集群原理]]></title>
    <url>%2F2018%2F04%2F01%2Fes_cluster%2F</url>
    <content type="text"><![CDATA[ElasticSearch搜索引擎原理总结 ElasticSearch的几种节点类型 Master Eligible Node （候选主节点）：设置成node.master=true (default)都可能会被选举为主节点； Master Node （主节点）：由候选主节点选举出来的，负责管理 ES 集群，通过广播的机制与其他节点维持关系，负责集群中的 DDL 操作（创建/删除索引），管理其他节点上的分片（shard）； Data Node（数据节点）：很好理解，存放数据的节点，负责数据的增删改查 CRUD； Ingest Node（提取节点）：能执行预处理管道，有自己独立的任务要执行，类似于 logstash 的功能，不负责数据也不负责集群相关的事务； Tribe Node（部落节点）：协调集群与集群之间的节点； Coordinating Node(协调节点)：每一个节点都是一个潜在的协调节点，且不能被禁用，协调节点最大的作用就是将各个分片里的数据汇集起来一并返回给客户端，因此 ES 的节点需要有足够的 CPU 和内存去处理协调节点的 gather 阶段 ElasticSearch集群启动过程ElasticSearch Gateway模块gateway模块用于存储es集群的元数据信息。这部分信息主要包括所有的索引连同索引设置和显式的mapping信息。集群元数据的每一次改变（比如增加删除索引等），这些信息都要通过gateway模块进行持久化。当集群第一次启动的时候，这些信息就会从gateway模块中读出并应用。设置在node级别上的gateway会自动控制索引所用的gateway。比如设置了local gataway，则每一个在这个node上创建的index都会应用他们在索引级别的local gateway。如果索引不需要持久化状态，需要显式的设置为none（这也是唯一可以设置的值）。默认的gateway设置是local gateway。 ElasticSearch文档（Type）更新过程协调节点负责创建索引,转发请求到主分片节点,等待响应,回复客户端 路径:action.index.TransportIndexAction#doExecute检查索引是否存在,如果不存在,且允许自动创建索引,就创建他 创建索引请求被发送到 master, 直到收到其 Response 之后,进入写doc操作主逻辑.master 什么时候返回Response? 在 master 执行完创建索引流程,将新的 clusterState 发布完毕后才会返回.那什么才算发布完毕呢?默认情况下,master 发布 clusterState 的 Request 收到半数以上的节点 Response, 认为发布成功.负责写数据的节点会先走一遍内容路由的过程已处理没有收到最新 clusterState 的情况. To be continued]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员如何成为自由职业者]]></title>
    <url>%2F2018%2F02%2F03%2Ffreelancer%2F</url>
    <content type="text"><![CDATA[你作为一个开发者，会有另一半，买房还贷，建立家庭，你会有孩子，一日五六餐嗷嗷吃钱，你还需要赡养老人，你需要越来越多的钱，才能凑凑合合地安排好你的生活。然而虽然你技术越来越好，贡献越来越大，客户却始终是老板的，而老板却要控制成本，万万不能给你越来越多的钱，他始终要把你框在预算之内。甚至，当你老了，精力、能力、干劲都开始走下坡路，他还会觉得你性价比不如那些年轻敢拼肯加班的新人高，于是你又得为地位不保失业在即而焦虑。 时间永是流逝，生活依然继续，你需要更多的时间、金钱来扮演好丈夫（妻子）、父亲（母亲）、儿子（女儿）、女婿（媳妇）等各种角色，固定的薪水，朝九晚五的节奏，很快都成了羁绊。于是，你开始向往“想干什么干什么，想怎么赚钱怎么赚钱，想赚多少赚多少”的生活，自由职业成了你倍感兴趣的选择。 那么，问题来了：作为一名开发者，该如何走向自由职业呢？ 走向自由职业的4种常见方式技术出色的开发者，通常具有下列能力： 软件开发，即针对特定领域问题，运用思维、分析、设计、想象力等寻找答案，通过语言、技术框架、工具等编写软件来实现答案的能力。 讲授，即把自己明白的技术、软件、解决方案等展示给别人并让别人也明白的能力。 咨询，即通过你所储备的知识、技能、经验、框架等帮助别人解决问题的能力。 热爱分享的开发者还会拥有另一项核心竞争力：写作。软件开发、讲授、写作、咨询这四种能力，构成了开发者走向自由职业的 4 种常见方式。 软件开发很多开发者都听说过“私活”，也接过私活。所谓私活，就是个人通过某种途径承接的软件项目，相对于公司的“公”而言，这种形式被称为“私”，现在这种方式还有很多说法，比如外包、众包、任务等。这是我们开发者走向自由职业的最常见方式。除了软件开发，你还需要下列能力： 客户开发 商务谈判 项目管理 这种方式很直接，不断开发客户，承接项目，赚取报酬。其好处是：你获得的报酬是按项目金额来的，而不是按月薪。套用某二手车买卖平台的广告语，没有中间商赚差价。想想看，你在公司，一个项目是 100 万，你一个人一个月搞定了，也还是拿三几万的薪水；而如果你自己接到这个项目，一个月完成，那你这个月就赚到 100 万（暂不考虑增值税、个人所得税等隐性成本）。天差地别对吧。所以独立开发软件项目是诱惑力很强的方式！但是这种方式也有一些比较困扰人的问题： 你并不总是能接到项目 需求可能不断变化，你需要直接面对这点，还要管理这种状况 项目款不一定能及时到账，尾款也不见得能收回来 还有，如果你想独自承接稍大一点的项目，你还需要注册一个公司来承接项目（稍大点儿的项目都是公对公），拥有一家公司，也会产生一些成本，比如代账、房产税、企业所得税等。 不过现在的众包方式，会好一些，像解放号、云沃客、码市、程序员客栈等平台，都有使用这种方式协作的项目，你只要做你擅长的事情——软件开发——就好了，别的事情由别人或平台来完成（你需要支付平台一些提现费用，一般10%左右）。 讲授如果你具有良好的讲授能力，就能把自己在某个技术栈上深厚的积累换一个形式变现：讲课。没错，你可以把自己学精学透的技术讲给别人听，把别人教明白。这是非常有价值的事情！很多人在初学某种技术时都需要好的老师好的教程帮助他们跨过从不知道到知道、从知道到做到的距离。IT 技能类的课程，能帮助别人掌握一技之长，帮助别人赚到钱，需求一直很旺盛。这些年线上的平台发展很快，很多学员也愿意低成本在线学习，像 51CTO 学院、CSDN 学院、慕课网、极客学院、网易云课堂、腾讯课堂、淘宝教育等平台，都很受欢迎。如果你可以运用讲授能力，把自己的技术积累转化为在线课程，就可以利用在线教育这种方式实现自由职业。我所潜伏的 51CTO 讲师群里，有不少靠编程课程实现自由职业的讲师，原来都是开发者。在双 11 、IT充电节等活动期间，有很多讲师一天销售额过万。 这种方式有几项好处： 启动成本低 受众面广 一份时间卖多次，想象空间大 写作写作是程序员自由飞翔的翅膀，它能帮你积累影响力，建立个人品牌，并且，也能够直接变现。对于开发者来讲，写作是通往自由之路最强有力的武器。写作这条路具有无与伦比的好处： 启动成本低 个人可以独立完成 可以直接建立影响力和个人品牌 一份时间卖无数次，有想象力 它最大的困难在于： 如何写好 如何捕捉到更为广泛且强烈的需求 如何持续写下去 咨询如果你看过《我的前半生》这部电视剧，一定对贺涵印象深刻，他做的就是咨询工作：用自己的知识、经验、技能、思维、框架等帮别人解决问题。在 IT 领域，如果你有完善的技能树和丰富的经验，能够站在较高的层面上做全局性思考，善于寻本溯源条分缕析解决问题，也可以从事咨询顾问之类的工作，不受雇于特定的组织，直接为客户服务。著名网站酷壳的创建者左耳朵耗子陈皓，擅长底层技术架构，对高性能，高可用性，分布式，高并发，以及大规模数据处理系统有丰富的经验和心得，他有段时间因为个人原因不能在公司上班，就通过为其他公司提供技术咨询来获取收入，并且，收入还蛮高。我有段时间就希望通过为一些公司提供技术咨询来赚钱，但没有成功。我还记得有家公司的老板对我说的话：你加入我们公司，带着团队把项目做起来，然后就可以成为我们的咨询顾问。看见了吧，这就是独立咨询的难处：当你不够牛 X 时，没有人愿意为你不知所谓无法确认效果的咨询付费，开发客户很难很难。ThoughtWorks 的很多咨询顾问虽然有公司为其背书，也还是常常遭人诟病：你自己没做过什么项目，凭什么给我们提供建议？虽然很难，但这确实是一条路，如果你有志于此，可以看看享誉世界 IT 领域的咨询顾问、美国计算机名人堂代表人物杰拉尔德·温伯格写的《咨询的奥秘》，那是圣经式的著作。当然，除此之外，你还要在自由之前，就积累一些客户资源，并且为客户留下你具备咨询能力的深刻印象，这样他们才可能成为你自由后的衣食父母。 走向自由职业必做的5种准备如果你确认了走向自由职业的方式，接下来就该做准备了。根据我的个人经验，下面 5 种准备是必须要做的： 变现方式 市场测试 饱和度测试 预期管理 B和Z方案 变现方式我所说的变现方式，包含两种：卖时间和卖产品。这里的卖时间，指“一份时间卖一次”这种工作方式。你在企业内工作，就是在卖时间，朝九晚五，每天 8 小时，每个月领薪水。以卖时间的方式实现自由职业，实质还是用你的专业能力为客户提供时间层面上的专属服务（你不可能在同一时刻为不同的客户服务），只是你不再受雇于企业，不再受规章制度约束，能够按照你自己的意愿安排在什么时间用什么方式完成服务。外包、众包、私活、咨询等方式，都是卖时间。卖产品则是指“一份时间卖多次”这种工作方式，像我们前面提到的写作、在线课程等，都可以归为此类。它相比卖时间的方式，具有更大的想象空间，可以获得规模化的收入。可能你写出一本经典、畅销的书，做出一个爆款的课程，就可以获得几十万的收入。在自由职业之前，你需要确认你最突出的能力，选定你首要的变现方式——因为你业余时间有限，不可能同时做很多事情。 市场测试在离开组织自由职业之前，你需要测试一下，你赖以实现自由职业的变现方式，可以给你带来多大规模的收入。比如你做技术课程，一定要先在业余时间开发几门课程，放到 51CTO 学院或者腾讯课堂之类的在线教育平台上去卖卖看，统计一下收入情况，看这些收入能不能维持你可以接受的生活水平。比如你写书，也要出版一本，观察半年，看看销量，看看能拿到多少版税。前面提到的杨开振，他是利用业余时间写出了《深入浅出MyBatis技术原理与实战》这本书，半年内卖了 2 万册，拿到了十几万的版税，才决定自由职业的。比如你做软件外包或者私活，也要开发几个客户接几个项目看看收入情况；如果做众包，则可以到云沃客、解放号、程序员客栈、码市等地方去验证半年左右，看自己的开发技能，能为自己带来多少单子多少收入。 如果你不做任何准备，不经市场测试，脑子一热就脱离组织，往往会陷入冷启动的泥沼，肠子悔青。假如做市场测试时发现收入很低，做不起来，不要气馁，要看看别人，尤其是和你经验、水平、身份差不多的人，有没有做得好的。比如我写书，版税很低，一本卖三五千册，不赚什么钱。可是杨开振一本书半年卖 2 万册，版税谈得也高，就有很可观的收入。那这个时候，就要找差距，看怎么提高。 饱和度测试自由职业不是不工作，只是不在组织内工作而已，你依然要投入足够的时间才能创造像样的产出赚到你想要的钱。你在单位上班时，老板们会给你安排事情，你不用考虑工作负荷是否饱和，哪怕你一天到晚没事儿干，也可以领到一份薪水。自由职业后就不一样了，你必须主动安排工作，让自己有足够的负荷，否则你逍遥自在不了多久就会陷入困境。饱和度测试就是要让你提前适应自由职业后自我安排工作的特点，看看你规划出来准备在自由职业时做的事情，能不能把你的时间填满。 可以分两步： 先全力去做，看能不能把你现在的业余时间填满。假如填不满，Ok，你不用自由职业，就继续现在的工作，业余时间做你想做的事情，赚一份额外收入就行了。 假如你现在业余时间远远不够用，那估算下到底会占多少时间，平均每天几个小时。假如平均每天4个小时，那Ok，另外 4 个小时你做什么？你需要再找点儿事情来填满它，可以是赚钱的事情，也可以是兴趣、爱好、休闲，总之你如果有大把时间无事可干，就会出问题。 预期管理预期管理包括四个方面： 冷启动周期。像接项目、写书、在线课程，都有个回款周期，所以你应该设想一下，你可以承受的无收入的起始阶段有多长，并为此准备一些钱，比如你预计周期为 3 个月，那你就要准备上至少够 3 个月花的钱。 收入预期，最近三年，预期收入达到什么规模。 时间预期，准备做多久来验证自己真的可以持续走下去。 成就预期，你打算在哪个方向上取得什么成就、建立什么名声。 B和Z方案你要设想，万一你现在规划的事情，收入不如预期，不能保持你的生活水准，你还准备再做些什么？这就是你的 B 方案，你要有至少 2 种可以变现的事情。再设想一下最坏的情况：万一你无论如何都养不活自己，该怎么应对，是回单位上班？还是吃存款、继续硬撑？你一定要提前做好备案，这样才可以从容应对。 自由职业的自由与焦虑在这篇文章的开始部分，我们说“你需要更多的时间、金钱来扮演好丈夫（妻子）、父亲（母亲）、儿子（女儿）、女婿（媳妇）等各种角色”，因此你考虑自由职业。但是，真实的自由职业，可能并没有想象中那么美好，它有自由，也有不自由，有高收入，也有与自由和不确定性伴生的焦虑。 自由女儿看牙，时间约到周一下午，没关系，直接去了，不用请假。复诊，约到周五下午，没关系，直接去了，不用请假。朋友约见面聊天，周三中午，没关系，直接去了，不用请假，因为不用考虑上班的事情，聊到几点是几点。今天我累了，就晚点起来，没关系，不用担心上班迟到。今天晚上我有兴致，可以写作到凌晨2点，没关系，第二天不用上班。 你看，这就是自由职业最大的好处：拥有安排工作时间的自由。只要你完成任务解决问题，鬼才管你什么时间工作。然而，你的自由是建立在自律的基础上的，你的自由是如何安排自己工作的自由，而不是不工作想干什么就干什么的自由（那是财务自由）——因为你要赚钱养活自己。 举个例子，你答应了客户周四完成开发交付软件的第一个版本，结果你周一周二都有事情，代码没完成，可以把交付日期更改到下周一吗？不行！如果你在单位做事情，可以找上司说：“哎呀老板，出现了点状况，是这么这么回事儿，看来这个事情得延期一周才行……”也许这样老板就会答应，你就又有了时间。可是你自由职业后，没有老板啊，你得自己维护自己“值得被信任”的形象，得让你的雇主觉得你“靠谱”。所以，你承诺了就要做到，哪怕熬夜赶出来哇！ 这就是一种不自由。 焦虑上班最大的一个好处是：不用考虑你要做什么事情，不用考虑你做的事情能不能创造经济价值，不管怎样，你都每月固定拿薪水。只要你在单位待着，哪怕刷一天朋友圈，也有钱拿！这是多么大的幸福啊！可是自由职业者就不一样：不做事就没钱啊。而且，更尴尬的是，做事也不一定有钱啊。所以，自由职业者每天都会受到不确定性的干扰。譬如我，用了记账软件记录收支，每次看到一大片红色就焦虑，心里就琢磨，哎呀我的钱什么时候到账啊。要是看到这个月的支出已经远超收入，就焦虑得不行，哎呀，差这么多啊，下个月能不能补赚回来啊。 这是你对收入波动性的焦虑，尤其容易出现在刚刚成为自由职业者的时候。还有第二种焦虑：你做的事情是否能够持续。 现在，你知道了一切：开发者实现自由职业的 4 种常见方式，5 种必做准备，以及可能的自由和焦虑。你准备开始吗？ 本文摘选自知乎 程序员如何成为自由职业者]]></content>
      <categories>
        <category>职业</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
