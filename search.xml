<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【JAVA回顾】匿名内部类]]></title>
    <url>%2F2018%2F04%2F07%2Fanonymous-inner-class%2F</url>
    <content type="text"><![CDATA[匿名内部类用法 使用匿名内部内部类匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下： 1234new 父类构造器（参数列表）|实现接口（）&#123; //匿名内部类的类体部分&#125; 在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有 class 关键字，这是因为匿名内部类是直接使用 new 来生成一个对象的引用。当然这个引用是隐式的。 12345678910111213141516171819202122232425262728293031323334353637public abstract class Bird &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public abstract int fly();&#125;public class Test &#123; public void test(Bird bird)&#123; System.out.println(bird.getName() + "能够飞 " + bird.fly() + "米"); &#125; public static void main(String[] args) &#123; Test test = new Test(); test.test(new Bird() &#123; public int fly() &#123; return 10000; &#125; public String getName() &#123; return "大雁"; &#125; &#125;); &#125;&#125;------------------Output：大雁能够飞 10000米 在 Test 类中，test() 方法接受一个 Bird 类型的参数，同时我们知道一个抽象类是没有办法直接 new 的，我们必须要先有实现类才能 new 出来它的实现类实例。所以在 mian 方法中直接使用匿名内部类来创建一个 Bird 实例。由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。对于这段匿名内部类代码其实是可以拆分为如下形式： 123456789101112public class WildGoose extends Bird&#123; public int fly() &#123; return 10000; &#125; public String getName() &#123; return "大雁"; &#125;&#125;WildGoose wildGoose = new WildGoose();test.test(wildGoose); 在这里系统会创建一个继承自 Bird 类的匿名类的对象，该对象转型为对 Bird 类型的引用。对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对 test() 方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。 注意事项在使用匿名内部类的过程中，我们需要注意如下几点： 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口 匿名内部类中是不能定义构造函数的 匿名内部类中不能存在任何的静态成员变量和静态方法 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法 使用的形参为何要为 final我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为 final。也就是说：当所在的方法的形参需要被内部类里面使用时，该形参必须为 final。为什么必须要为 final 呢？首先我们知道在内部类编译成功后，它会产生一个 class 文件，该 class 文件与外部类并不是同一 class 文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从 java 程序的角度来看是直接被调用： 123456789public class OuterClass &#123; public void display(final String name,String age)&#123; class InnerClass&#123; void display()&#123; System.out.println(name); &#125; &#125; &#125;&#125; 从上面代码中看好像 name 参数应该是被内部类直接调用？其实不然，在 java 编译之后实际的操作如下： 12345678910public class OuterClass$InnerClass &#123; public InnerClass(String name,String age)&#123; this.InnerClass$name = name; this.InnerClass$age = age; &#125; public void display()&#123; System.out.println(this.InnerClass$name + "----" + this.InnerClass$age ); &#125;&#125; 所以从上面代码来看，内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。直到这里还没有解释为什么是 final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变。 简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用 final 来让该引用不可改变。 故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是 final 的。 匿名内部类初始化我们一般都是利用构造器来完成某个实例的初始化工作的，但是匿名内部类是没有构造器的！那怎么来初始化匿名内部类呢？使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果。 1234567891011121314151617181920212223242526272829303132public class OutClass &#123; public InnerClass getInnerClass(final int age,final String name)&#123; return new InnerClass() &#123; int age_ ; String name_; //构造代码块完成初始化工作 &#123; if(0 &lt; age &amp;&amp; age &lt; 200)&#123; age_ = age; name_ = name; &#125; &#125; public String getName() &#123; return name_; &#125; public int getAge() &#123; return age_; &#125; &#125;; &#125; public static void main(String[] args) &#123; OutClass out = new OutClass(); InnerClass inner_1 = out.getInnerClass(201, "chenssy"); System.out.println(inner_1.getName()); InnerClass inner_2 = out.getInnerClass(23, "chenssy"); System.out.println(inner_2.getName()); &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA回顾】final关键字]]></title>
    <url>%2F2018%2F04%2F07%2Fjava-final%2F</url>
    <content type="text"><![CDATA[FINAL关键字用法&amp;总结 final 是 Java 中非常常见的一个关键字，可以说每天都在使用它，虽然常见，但却也不见得都那么显而易见，今天就来研究一下 final，以加深对它的理解和更合理的运用。 修饰类当一个类不想被继承时，就可以用 final 来修饰。 修饰方法当一个方法不想被子类覆写 (Override) 时，可以用 final 来修饰。另外一方面，把方法用 final 来修饰也有一定的性能提升上的帮助，因为虚拟机知道它不会被覆写，所以可以以更简单的方式来处理。private 的方法，默认都会被编译器加上 final. 修饰变量被 final 修饰的变量只能赋值一次，之后不能再被修改。如：12final int a = 10;a = 4; // compilation error 需要注意的是，这里说的是只能赋值一次，并不意味着，非要在声明变量时直接初始化，比如，下面的代码也是完全合法的：123456final int a;if (foo()) &#123; a = 3;&#125; else &#123; a = 4;&#125; 修饰域变量域变量也是变量，所以用 final 来修饰的第一个作用就是赋值后，不能再修改变量的值，比如:12final int a = 10;final Object b = new Object(); 对于基本类型来说，就是变量值不能再被修改；对于引用来说，就是不能再让其指向其他对象或者 null。但对于域变量，声明为 final 的域变量必须在声明时初始化，或者在构造方法中初始化，否则会有编译错误。此外，声明为 final 的域变量还有内存模型上的语义，下面详细说 防止变量从构造方法中逸出(内存模型的作用)这个主要是针对被 final 修饰的域变量，虚拟机会有禁止指令重排的保证： 在构造方法内对一个 final 变量的写入，与随后这个被构造对象的引用赋值给一个引用变量，这二个顺序不改变，final 变量的写入一定要早于对象引用的赋值。什么意思呢？在多线程环境下，域变量是有可能从构造方法中逸出的，也就是说线程有可能读到还没有被构造方法初始化的域变量的值。比如：1234567class Foo &#123; int a; Foo(int v) &#123; a = v; &#125;&#125; 如果是在多线程环境下，一个线程 A 在创建 Foo 的对象，另一个线程 B 在读对象的 a 的值，则 B 是有可能读到未正确初始化 a 的值（默认初始值 0）。这就是域变量从构造方法中逸出。关键字 final 可以禁止虚拟机指令重排，从而保证了构造方法执行完毕前 final 修饰的变量一定是初始化过了的。这部分可以参考深入理解 Java 内存模型（六）——final，讲解的非常详细。 匿名内部类使用外部变量时为何要强制使用 final 修饰这个大家肯定都习以为常了，比如：1234567891011private void initViews() &#123; final int a = 3; // Compilation error if remove final btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (a &gt; 1) &#123; // volala &#125; &#125; &#125;&#125; 那么，有没有想过为什么？而像其他支持完整闭包的语言如 JavaScript，Python 等，是没有这等限制的。究其原因，是 Java 对闭包支持不够完整，或者说它并不是像动态语言那样的完整闭包。对于匿名内部类来说，编译器会创建一个命名类 (OutClass$1 之类的)，然后把匿名类所在的能捕获的变量)，以构造参数的形式传递给内部类使用，这样一样，外部的变量与内部类看到的变量是不同的，虽然它们的值是相同的，因此，如果再允许外部修改这些变量，或者内部类里面修改这些变量，都会造成数据的不一致性（因为它们是不同的变量），所以 Java 强制要求匿名内部类访问的外部变量要加上 final 来修饰。对于其他语言，匿名内部类，持有的是外部变量的一个包装的引用 (wrapper reference)，这可以能看不懂，但是理解起来就是内部类能直接访问外部变量，外部与闭包内部访问的是同一个变量，因此外部修改了，内部能看到变化，内部修改了，外部也能看到变化。一句话总结就是，Java 内部类与外部持有的是值相同的不同的变量；其他支持闭包的语言则持有的是相同的变量。 建议能使用 final 的地方就加上 final 修饰最后来聊聊，啥时候应该用 final 呢？孤的建议 (以及众多大师的建议) 就是能多用就多用，除非不能用 final，否则就用。原因，有这么几条： 域变量尽可能加上 final这个原因比较明确，前面也提到了，在多线程条件下，会有很大的优势。尽可能加上 final 来修饰域变量，甚至用 Immutable Object，可以省去构造时的多线程同步。多线程最大的麻烦是状态同步，啥是状态？其实就是共享数据，域变量就是共享数据，所以，如果共享数据都是不可变的 (Immutable)，那么自然就没有了同步上的麻烦。 final 类和方法能提升性能正常的类和方法，虚拟机需要为了继承和方法覆写而做一次准备，如果加上了 final，虚拟机知道它不会被继承或者覆写，那么就可以做一些优化。虽然，这并不显著，但是还是可以提升一些性能的。 final 变量能提升可读性无论是域变量还是本地变量，加上了 final 修饰，程序的维护者就知道了，这个变量的值不会再改变，这无疑会大大增加可读性。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JAVA回顾】STATIC关键字]]></title>
    <url>%2F2018%2F04%2F07%2Fjava-static%2F</url>
    <content type="text"><![CDATA[STATIC关键字用法&amp;总结 初识 staticstatic 是 “静态” 的意思，这个大家应该都清楚，静态变量，静态方法大家也都能随口道来。但是，你真的理解静态变量和静态方法么？除了这些 static 还有什么用处？ 事实上，static 大体上有五种用法： 静态导入 静态变量 静态方法 静态代码段 静态内部类 接下来，我们将逐个看一下这些用法。 静态导入也许有的人是第一次听说静态导入，反正我在写这篇文章之前是不清楚 static 还可以这样用的。什么是静态导入呢？我们先来看一段代码： 12345678910public class OldImport &#123; public static void main(String[] args) &#123; double a = Math.cos(Math.PI / 2); double b = Math.pow(2.4,1.2); double r = Math.max(a,b); System.out.println(r); &#125;&#125; 看到这段代码，你有什么想说的么？啥？没有？你不觉得 Math 出现的次数太多了么？ 恩，你觉得好像是有点多，怎么办呢？看下面： 123456789101112import static java.lang.Math.*;public class StaticImport &#123; public static void main(String[] args) &#123; double a = cos(PI / 2); double b = pow(2.4,1.2); double r = max(a,b); System.out.println(r); &#125;&#125; 这就是静态导入。我们平时使用一个静态方法的时候，都是【类名. 方法名】，使用静态变量的时候都是【类名. 变量名】，如果一段代码中频繁的用到了这个类的方法或者变量，我们就要写好多次类名，比如上面的 Math，这显然不是喜欢偷懒的程序员所希望做的，所以出现了静态导入的功能。 静态导入，就是把一个静态变量或者静态方法一次性导入，导入后可以直接使用该方法或者变量，而不再需要写对象名。 怎么样，是不是觉得很方便？如果你以前不知道这个，你大概在窃喜，以后可以偷懒了。先别高兴的太早，看下面的代码： 123456789101112131415161718import static java.lang.Double.*;import static java.lang.Integer.*;import static java.lang.Math.*;import static java.text.NumberFormat.*;public class ErrorStaticImport &#123; // 输入半径和精度要求，计算面积 public static void main(String[] args) &#123; double s = PI * parseDouble(args[0]); NumberFormat nf = getInstance(); nf.setMaximumFractionDigits(parseInt(args[1])); formatMessage(nf.format(s)); &#125; // 格式化消息输出 public static void formatMessage(String s)&#123; System.out.println(&quot; 圆面积是：&quot;+s); &#125;&#125; 就这么一段程序，看着就让人火大：常量 PI，这知道，是圆周率；parseDouble 方法可能是 Double 类的一个转换方法，这看名称也能猜测到。那紧接着的 getInstance 方法是哪个类的？是 ErrorStaticImport 本地类的方法？不对呀，没有这个方法，哦，原来是 NumberFormate 类的方法，这和 formateMessage 本地方法没有任何区别了。这代码也太难阅读了，这才几行？要是你以后接别人的代码，看到成千上万行这种代码大概你想死的心都有了吧？ 所以，不要滥用静态导入！！！不要滥用静态导入！！！不要滥用静态导入！！！ 正确使用静态导入的姿势是什么样子的呢？ 1234567891011121314151617181920import java.text.NumberFormat;import static java.lang.Double.parseDouble;import static java.lang.Integer.parseInt;import static java.lang.Math.PI;import static java.text.NumberFormat.getInstance;public class ErrorStaticImport &#123; // 输入半径和精度要求，计算面积 public static void main(String[] args) &#123; double s = PI * parseDouble(args[0]); NumberFormat nf = getInstance(); nf.setMaximumFractionDigits(parseInt(args[1])); formatMessage(nf.format(s)); &#125; // 格式化消息输出 public static void formatMessage(String s)&#123; System.out.println(&quot; 圆面积是：&quot;+s); &#125;&#125; 没错，这才是正确的姿势，你使用哪个方法或者哪个变量，就把他导入进来，而不要使用通配符（*）！ 并且，由于不用写类名了，所以难免会和本地方法混淆。所以，本地方法在起名字的时候，一定要起得有意义，让人一看这个方法名大概就能知道你这个方法是干什么的，而不是什么 method1(),method2()，鬼知道你写的是什么。。 总结： 不使用 * 通配符，除非是导入静态常量类（只包含常量的类或接口）。 方法名是具有明确、清晰表象意义的工具类。 这里有一个小插曲，就是我在用 idea 写示例代码的时候，想用通配符做静态导入，结果刚写完，idea 自动给我改成非通配符的了，嘿我这暴脾气，我再改成通配符！特喵的。。又给我改回去了。。。事实证明，用一个好的 IDE，是可以提高效率，比呢且优化好你的代码的，有的时候后，想不优化都不行。哈哈哈，推荐大家使用 idea。 静态变量 这个想必大家都已经很熟悉了。我就再啰嗦几句。 java 类提供了两种类型的变量：用 static 修饰的静态变量和不用 static 修饰的成员变量。 静态变量属于类，在内存中只有一个实例。当 jtbl 所在的类被加载的时候，就会为该静态变量分配内存空间，该变量就可以被使用。jtbl 有两种被使用方式：【类名. 变量名】和【对象. 变量名】。 实例变量属于对象，只有对象被创建后，实例对象才会被分配空间，才能被使用。他在内存中存在多个实例，只能通过【对象. 变量名】来使用。 java 的内存大体上有四块：堆，栈，静态区，常量区。其中的静态区，就是用来放置静态变量的。当静态变量的类被加载时，虚拟机就会在静态区为该变量开辟一块空间。所有使用该静态变量的对象都访问这一个空间。 一个例子学习静态变量与实例变量。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class StaticAttribute &#123; public static int staticInt = 10; public static int staticIntNo ; public int nonStatic = 5; public static void main(String[] args) &#123; StaticAttribute s = new StaticAttribute(); System.out.println(&quot;s.staticInt= &quot; + s.staticInt); System.out.println(&quot;StaticAttribute.staticInt= &quot; + StaticAttribute.staticInt); System.out.println(&quot;s.staticIntNo= &quot; + s.staticIntNo); System.out.println(&quot;StaticAttribute.staticIntNo= &quot; + StaticAttribute.staticIntNo); System.out.println(&quot;s.nonStatic= &quot; + s.nonStatic); System.out.println(&quot;使用s,让三个变量都+1&quot;); s.staticInt ++; s.staticIntNo ++; s.nonStatic ++; StaticAttribute s2 = new StaticAttribute(); System.out.println(&quot;s2.staticInt= &quot; + s2.staticInt); System.out.println(&quot;StaticAttribute.staticInt= &quot; + StaticAttribute.staticInt); System.out.println(&quot;s2.staticIntNo= &quot; + s2.staticIntNo); System.out.println(&quot;StaticAttribute.staticIntNo= &quot; + StaticAttribute.staticIntNo); System.out.println(&quot;s2.nonStatic= &quot; + s2.nonStatic); &#125;&#125;// 结果：// s.staticInt= 10// StaticAttribute.staticInt= 10// s.staticIntNo= 0// StaticAttribute.staticIntNo= 0// s.nonStatic= 5// 使用s,让三个变量都+1// s2.staticInt= 11// StaticAttribute.staticInt= 11// s2.staticIntNo= 1// StaticAttribute.staticIntNo= 1// s2.nonStatic= 5 从上例可以看出，静态变量只有一个，被类拥有，所有对象都共享这个静态变量，而实例对象是与具体对象相关的。 与 c++ 不同的是，在 java 中，不能在方法体中定义 static 变量，我们之前所说的变量，都是类变量，不包括方法内部的变量。 那么，静态变量有什么用途呢？ 静态变量的用法最开始的代码中有一个静态变量 — PI，也就是圆周率。为什么要把它设计为静态的呢？因为我们可能在程序的任何地方使用到这个变量，如果不是静态的，那么我们每次使用这个变量的时候都要创建一个 Math 对象，不仅代码臃肿而且浪费了内存空间。 所以，当你的某一个变量会经常被外部代码访问的时候，可以考虑设计为静态的。 静态方法 同样，静态方法大家应该也比较熟悉了。就是在定义类的时候加一个 static 修饰符。 与静态变量一样，java 类也同时提供了 static 方法和非 static 方法。 static 方法是类的方法，不需要创建对象就可以使用，比如 Math 类里面的方法。使用方法【对象. 方法名】或者【类名. 方法名】 非 static 方法是对象的方法，只有对象呗创建出来以后才可以被使用。使用方法【对象. 方法名】 static 怎么用代码写我想大家都知道，这里我就不举例了，你们看着烦，我写着也烦。 注意事项static 方法中不能使用 this 和 super 关键字，不能调用非 static 方法，只能访问所属类的静态变量和静态方法。因为当 static 方法被调用的时候，这个类的对象可能还没有创建，即使已经被创建了，也无法确认调用那个对象的方法。不能访问非静态方法同理。 用途—单例模式static 的一个很常见的用途是实现单例模式。单例模式的特点是一个类只能有一个实例，为了实现这一功能，必须隐藏该类的构造函数，即把构造函数声明为 private，并提供一个创建对象的方法。我们来看一下怎么实现： 1234567891011121314public class Singleton &#123; private static Singleton singleton; public static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125; private Singleton() &#123; &#125;&#125; 这个类，只会有一个对象。 其他用 public 修饰的 static 成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成 static 变量的副本，而是类的所有实例共享同一个 static 变量。 static 变量前可以有 private 修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用（当然也可以在非静态成员方法中使用–废话），但是不能在其他类中通过类名来直接引用，这一点很重要。 实际上你需要搞明白，private 是访问权限限定，static 表示不要实例化就可以使用，这样就容易理解多了。static 前面加上其它访问权限关键字的效果也以此类推。 静态方法的用场静态变量可以被非静态方法调用，也可以被静态方法调用。但是静态方法只能被静态方法调用。 一般工具方法会设计为静态方法，比如 Math 类中的所有方法都是惊天的，因为我们不需要 Math 类的实例，我们只是想要用一下里面的方法。所以，你可以写一个通用的 工具类，然后里面的方法都写成静态的。 静态代码块在讲静态代码块之前，我们先来看一下，什么是代码块。 什么是代码块所谓代码块就是用大括号将多行代码封装在一起，形成一个独立的数据体，用于实现特定的算法。一般来说代码块是不能单独运行的，它必须要有运行主体。在 Java 中代码块主要分为四种：普通代码块，静态代码块，同步代码块和构造代码块。 四种代码块 普通代码块 普通代码块是我们用得最多的也是最普遍的，它就是在方法名后面用 {} 括起来的代码段。普通代码块是不能够单独存在的，它必须要紧跟在方法名后面。同时也必须要使用方法名调用它。 123public void common()&#123; System.out.println(&quot;普通代码块执行&quot;);&#125; 静态代码块 静态代码块就是用 static 修饰的用 {} 括起来的代码段，它的主要目的就是对静态属性进行初始化。 静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM 加载类时会执行这些静态的代码块，如果 static 代码块有多个，JVM 将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。 看一段代码： 12345678910111213public class Person&#123; private Date birthDate; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; Date startDate = Date.valueOf(&quot;1990&quot;); Date endDate = Date.valueOf(&quot;1999&quot;); return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; isBornBoomer 是用来这个人是否是 1990-1999 年出生的，而每次 isBornBoomer 被调用的时候，都会生成 startDate 和 birthDate 两个对象，造成了空间浪费，如果改成这样效率会更好： 12345678910111213141516public class Person&#123; private Date birthDate; private static Date startDate,endDate; static&#123; startDate = Date.valueOf(&quot;1990&quot;); endDate = Date.valueOf(&quot;1999&quot;); &#125; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; 因此，很多时候会将一些只需要进行一次的初始化操作都放在 static 代码块中进行。 同步代码块 使用 synchronized 关键字修饰，并使用 “{}” 括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制。 构造代码块 在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块。我们明白一个类必须至少有一个构造函数，构造函数在生成对象时被调用。构造代码块和构造函数一样同样是在生成一个对象时被调用，那么构造代码在什么时候被调用？如何调用的呢？ 看一段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class CodeBlock &#123; private int a = 1; private int b ; private int c ; //静态代码块 static &#123; int a = 4; System.out.println(&quot;我是静态代码块1&quot;); &#125; //构造代码块 &#123; int a = 0; b = 2; System.out.println(&quot;构造代码块1&quot;); &#125; public CodeBlock()&#123; this.c = 3; System.out.println(&quot;构造函数&quot;); &#125; public int add()&#123; System.out.println(&quot;count a + b + c&quot;); return a + b + c; &#125; //静态代码块 static &#123; System.out.println(&quot;我是静态代码块2，我什么也不做&quot;); &#125; //构造代码块 &#123; System.out.println(&quot;构造代码块2&quot;); &#125; public static void main(String[] args) &#123; CodeBlock c = new CodeBlock(); System.out.println(c.add()); System.out.println(); System.out.println(&quot;*******再来一次*********&quot;); System.out.println(); CodeBlock c1 = new CodeBlock(); System.out.println(c1.add()); &#125;&#125;//结果：//我是静态代码块1//我是静态代码块2，我什么也不做//构造代码块1//构造代码块2//构造函数//count a + b + c//6////*******再来一次*********////构造代码块1//构造代码块2//构造函数//count a + b + c//6 这段代码综合了构造代码块，普通代码块和静态代码块。我们来总结一下： 静态代码块只会执行一次。有多个静态代码块时按顺序依次执行。 构造代码块每次创建新对象时都会执行。有多个时依次执行。 执行顺序：静态代码块 &gt; 构造代码块 &gt; 构造函数。 构造代码块和静态代码块有自己的作用域，作用域内部的变量不影响作用域外部。 构造代码块的应用场景： 1、 初始化实例变量如果一个类中存在若干个构造函数，这些构造函数都需要对实例变量进行初始化，如果我们直接在构造函数中实例化，必定会产生很多重复代码，繁琐和可读性差。这里我们可以充分利用构造代码块来实现。这是利用编译器会将构造代码块添加到每个构造函数中的特性。 2、 初始化实例环境一个对象必须在适当的场景下才能存在，如果没有适当的场景，则就需要在创建对象时创建此场景。我们可以利用构造代码块来创建此场景，尤其是该场景的创建过程较为复杂。构造代码会在构造函数之前执行。 静态内部类被 static 修饰的内部类，它可以不依赖于外部类实例对象而被实例化，而通常的内部类需要在外部类实例化后才能实例化。静态内部类不能与外部类有相同的名字，不能访问外部类的普通成员变量，只能访问内部类中的静态成员和静态方法（包括私有类型）。 由于还没有详细讲解过内部类，这里先一笔带过，在讲解内部类的时候会详细分析静态内部类。 只有内部类才能被 static 修饰，普通的类不可以。 总结本文内容就先到这里，我们再来回顾一下学了什么： static 关键字的五种用法： 静态导入 静态变量 静态方法 静态代码块 静态内部类 代码块 普通代码块 静态代码块 构造代码块 同步代码块 回忆一下这些知识点的内容，如果想不起来，记得翻上去再看一遍~ 彩蛋 —— 继承 + 代码块的执行顺序如果既有继承，又有代码块，执行的顺序是怎样呢？ 12345678910111213141516171819202122232425262728293031323334353637public class Parent &#123; static &#123; System.out.println(&quot;父类静态代码块&quot;); &#125; &#123; System.out.println(&quot;父类构造代码块&quot;); &#125; public Parent()&#123; System.out.println(&quot;父类构造函数&quot;); &#125;&#125;class Children extends Parent &#123; static &#123; System.out.println(&quot;子类静态代码块&quot;); &#125; &#123; System.out.println(&quot;子类构造代码块&quot;); &#125; public Children()&#123; System.out.println(&quot;子类构造函数&quot;); &#125; public static void main(String[] args) &#123; new Children(); &#125;&#125;//结果：//父类静态代码块//子类静态代码块//父类构造代码块//父类构造函数//子类构造代码块//子类构造函数 结果你也知道了： 先执行静态内容 (先父类后子类)，然后执行父类非静态，最后执行子类非静态。（非静态包括构造代码块和构造函数，构造代码块先执行）]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch集群原理]]></title>
    <url>%2F2018%2F04%2F01%2Fes_cluster%2F</url>
    <content type="text"><![CDATA[ElasticSearch搜索引擎原理总结 ElasticSearch的几种节点类型 Master Eligible Node （候选主节点）：设置成node.master=true (default)都可能会被选举为主节点； Master Node （主节点）：由候选主节点选举出来的，负责管理 ES 集群，通过广播的机制与其他节点维持关系，负责集群中的 DDL 操作（创建/删除索引），管理其他节点上的分片（shard）； Data Node（数据节点）：很好理解，存放数据的节点，负责数据的增删改查 CRUD； Ingest Node（提取节点）：能执行预处理管道，有自己独立的任务要执行，类似于 logstash 的功能，不负责数据也不负责集群相关的事务； Tribe Node（部落节点）：协调集群与集群之间的节点； Coordinating Node(协调节点)：每一个节点都是一个潜在的协调节点，且不能被禁用，协调节点最大的作用就是将各个分片里的数据汇集起来一并返回给客户端，因此 ES 的节点需要有足够的 CPU 和内存去处理协调节点的 gather 阶段 ElasticSearch集群启动过程ElasticSearch Gateway模块gateway模块用于存储es集群的元数据信息。这部分信息主要包括所有的索引连同索引设置和显式的mapping信息。集群元数据的每一次改变（比如增加删除索引等），这些信息都要通过gateway模块进行持久化。当集群第一次启动的时候，这些信息就会从gateway模块中读出并应用。设置在node级别上的gateway会自动控制索引所用的gateway。比如设置了local gataway，则每一个在这个node上创建的index都会应用他们在索引级别的local gateway。如果索引不需要持久化状态，需要显式的设置为none（这也是唯一可以设置的值）。默认的gateway设置是local gateway。 ElasticSearch文档（Type）更新过程协调节点负责创建索引,转发请求到主分片节点,等待响应,回复客户端 路径:action.index.TransportIndexAction#doExecute检查索引是否存在,如果不存在,且允许自动创建索引,就创建他 创建索引请求被发送到 master, 直到收到其 Response 之后,进入写doc操作主逻辑.master 什么时候返回Response? 在 master 执行完创建索引流程,将新的 clusterState 发布完毕后才会返回.那什么才算发布完毕呢?默认情况下,master 发布 clusterState 的 Request 收到半数以上的节点 Response, 认为发布成功.负责写数据的节点会先走一遍内容路由的过程已处理没有收到最新 clusterState 的情况. To be continued]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员如何成为自由职业者]]></title>
    <url>%2F2018%2F02%2F03%2Ffreelancer%2F</url>
    <content type="text"><![CDATA[你作为一个开发者，会有另一半，买房还贷，建立家庭，你会有孩子，一日五六餐嗷嗷吃钱，你还需要赡养老人，你需要越来越多的钱，才能凑凑合合地安排好你的生活。然而虽然你技术越来越好，贡献越来越大，客户却始终是老板的，而老板却要控制成本，万万不能给你越来越多的钱，他始终要把你框在预算之内。甚至，当你老了，精力、能力、干劲都开始走下坡路，他还会觉得你性价比不如那些年轻敢拼肯加班的新人高，于是你又得为地位不保失业在即而焦虑。 时间永是流逝，生活依然继续，你需要更多的时间、金钱来扮演好丈夫（妻子）、父亲（母亲）、儿子（女儿）、女婿（媳妇）等各种角色，固定的薪水，朝九晚五的节奏，很快都成了羁绊。于是，你开始向往“想干什么干什么，想怎么赚钱怎么赚钱，想赚多少赚多少”的生活，自由职业成了你倍感兴趣的选择。 那么，问题来了：作为一名开发者，该如何走向自由职业呢？ 走向自由职业的4种常见方式技术出色的开发者，通常具有下列能力： 软件开发，即针对特定领域问题，运用思维、分析、设计、想象力等寻找答案，通过语言、技术框架、工具等编写软件来实现答案的能力。 讲授，即把自己明白的技术、软件、解决方案等展示给别人并让别人也明白的能力。 咨询，即通过你所储备的知识、技能、经验、框架等帮助别人解决问题的能力。 热爱分享的开发者还会拥有另一项核心竞争力：写作。软件开发、讲授、写作、咨询这四种能力，构成了开发者走向自由职业的 4 种常见方式。 软件开发很多开发者都听说过“私活”，也接过私活。所谓私活，就是个人通过某种途径承接的软件项目，相对于公司的“公”而言，这种形式被称为“私”，现在这种方式还有很多说法，比如外包、众包、任务等。这是我们开发者走向自由职业的最常见方式。除了软件开发，你还需要下列能力： 客户开发 商务谈判 项目管理 这种方式很直接，不断开发客户，承接项目，赚取报酬。其好处是：你获得的报酬是按项目金额来的，而不是按月薪。套用某二手车买卖平台的广告语，没有中间商赚差价。想想看，你在公司，一个项目是 100 万，你一个人一个月搞定了，也还是拿三几万的薪水；而如果你自己接到这个项目，一个月完成，那你这个月就赚到 100 万（暂不考虑增值税、个人所得税等隐性成本）。天差地别对吧。所以独立开发软件项目是诱惑力很强的方式！但是这种方式也有一些比较困扰人的问题： 你并不总是能接到项目 需求可能不断变化，你需要直接面对这点，还要管理这种状况 项目款不一定能及时到账，尾款也不见得能收回来 还有，如果你想独自承接稍大一点的项目，你还需要注册一个公司来承接项目（稍大点儿的项目都是公对公），拥有一家公司，也会产生一些成本，比如代账、房产税、企业所得税等。 不过现在的众包方式，会好一些，像解放号、云沃客、码市、程序员客栈等平台，都有使用这种方式协作的项目，你只要做你擅长的事情——软件开发——就好了，别的事情由别人或平台来完成（你需要支付平台一些提现费用，一般10%左右）。 讲授如果你具有良好的讲授能力，就能把自己在某个技术栈上深厚的积累换一个形式变现：讲课。没错，你可以把自己学精学透的技术讲给别人听，把别人教明白。这是非常有价值的事情！很多人在初学某种技术时都需要好的老师好的教程帮助他们跨过从不知道到知道、从知道到做到的距离。IT 技能类的课程，能帮助别人掌握一技之长，帮助别人赚到钱，需求一直很旺盛。这些年线上的平台发展很快，很多学员也愿意低成本在线学习，像 51CTO 学院、CSDN 学院、慕课网、极客学院、网易云课堂、腾讯课堂、淘宝教育等平台，都很受欢迎。如果你可以运用讲授能力，把自己的技术积累转化为在线课程，就可以利用在线教育这种方式实现自由职业。我所潜伏的 51CTO 讲师群里，有不少靠编程课程实现自由职业的讲师，原来都是开发者。在双 11 、IT充电节等活动期间，有很多讲师一天销售额过万。 这种方式有几项好处： 启动成本低 受众面广 一份时间卖多次，想象空间大 写作写作是程序员自由飞翔的翅膀，它能帮你积累影响力，建立个人品牌，并且，也能够直接变现。对于开发者来讲，写作是通往自由之路最强有力的武器。写作这条路具有无与伦比的好处： 启动成本低 个人可以独立完成 可以直接建立影响力和个人品牌 一份时间卖无数次，有想象力 它最大的困难在于： 如何写好 如何捕捉到更为广泛且强烈的需求 如何持续写下去 咨询如果你看过《我的前半生》这部电视剧，一定对贺涵印象深刻，他做的就是咨询工作：用自己的知识、经验、技能、思维、框架等帮别人解决问题。在 IT 领域，如果你有完善的技能树和丰富的经验，能够站在较高的层面上做全局性思考，善于寻本溯源条分缕析解决问题，也可以从事咨询顾问之类的工作，不受雇于特定的组织，直接为客户服务。著名网站酷壳的创建者左耳朵耗子陈皓，擅长底层技术架构，对高性能，高可用性，分布式，高并发，以及大规模数据处理系统有丰富的经验和心得，他有段时间因为个人原因不能在公司上班，就通过为其他公司提供技术咨询来获取收入，并且，收入还蛮高。我有段时间就希望通过为一些公司提供技术咨询来赚钱，但没有成功。我还记得有家公司的老板对我说的话：你加入我们公司，带着团队把项目做起来，然后就可以成为我们的咨询顾问。看见了吧，这就是独立咨询的难处：当你不够牛 X 时，没有人愿意为你不知所谓无法确认效果的咨询付费，开发客户很难很难。ThoughtWorks 的很多咨询顾问虽然有公司为其背书，也还是常常遭人诟病：你自己没做过什么项目，凭什么给我们提供建议？虽然很难，但这确实是一条路，如果你有志于此，可以看看享誉世界 IT 领域的咨询顾问、美国计算机名人堂代表人物杰拉尔德·温伯格写的《咨询的奥秘》，那是圣经式的著作。当然，除此之外，你还要在自由之前，就积累一些客户资源，并且为客户留下你具备咨询能力的深刻印象，这样他们才可能成为你自由后的衣食父母。 走向自由职业必做的5种准备如果你确认了走向自由职业的方式，接下来就该做准备了。根据我的个人经验，下面 5 种准备是必须要做的： 变现方式 市场测试 饱和度测试 预期管理 B和Z方案 变现方式我所说的变现方式，包含两种：卖时间和卖产品。这里的卖时间，指“一份时间卖一次”这种工作方式。你在企业内工作，就是在卖时间，朝九晚五，每天 8 小时，每个月领薪水。以卖时间的方式实现自由职业，实质还是用你的专业能力为客户提供时间层面上的专属服务（你不可能在同一时刻为不同的客户服务），只是你不再受雇于企业，不再受规章制度约束，能够按照你自己的意愿安排在什么时间用什么方式完成服务。外包、众包、私活、咨询等方式，都是卖时间。卖产品则是指“一份时间卖多次”这种工作方式，像我们前面提到的写作、在线课程等，都可以归为此类。它相比卖时间的方式，具有更大的想象空间，可以获得规模化的收入。可能你写出一本经典、畅销的书，做出一个爆款的课程，就可以获得几十万的收入。在自由职业之前，你需要确认你最突出的能力，选定你首要的变现方式——因为你业余时间有限，不可能同时做很多事情。 市场测试在离开组织自由职业之前，你需要测试一下，你赖以实现自由职业的变现方式，可以给你带来多大规模的收入。比如你做技术课程，一定要先在业余时间开发几门课程，放到 51CTO 学院或者腾讯课堂之类的在线教育平台上去卖卖看，统计一下收入情况，看这些收入能不能维持你可以接受的生活水平。比如你写书，也要出版一本，观察半年，看看销量，看看能拿到多少版税。前面提到的杨开振，他是利用业余时间写出了《深入浅出MyBatis技术原理与实战》这本书，半年内卖了 2 万册，拿到了十几万的版税，才决定自由职业的。比如你做软件外包或者私活，也要开发几个客户接几个项目看看收入情况；如果做众包，则可以到云沃客、解放号、程序员客栈、码市等地方去验证半年左右，看自己的开发技能，能为自己带来多少单子多少收入。 如果你不做任何准备，不经市场测试，脑子一热就脱离组织，往往会陷入冷启动的泥沼，肠子悔青。假如做市场测试时发现收入很低，做不起来，不要气馁，要看看别人，尤其是和你经验、水平、身份差不多的人，有没有做得好的。比如我写书，版税很低，一本卖三五千册，不赚什么钱。可是杨开振一本书半年卖 2 万册，版税谈得也高，就有很可观的收入。那这个时候，就要找差距，看怎么提高。 饱和度测试自由职业不是不工作，只是不在组织内工作而已，你依然要投入足够的时间才能创造像样的产出赚到你想要的钱。你在单位上班时，老板们会给你安排事情，你不用考虑工作负荷是否饱和，哪怕你一天到晚没事儿干，也可以领到一份薪水。自由职业后就不一样了，你必须主动安排工作，让自己有足够的负荷，否则你逍遥自在不了多久就会陷入困境。饱和度测试就是要让你提前适应自由职业后自我安排工作的特点，看看你规划出来准备在自由职业时做的事情，能不能把你的时间填满。 可以分两步： 先全力去做，看能不能把你现在的业余时间填满。假如填不满，Ok，你不用自由职业，就继续现在的工作，业余时间做你想做的事情，赚一份额外收入就行了。 假如你现在业余时间远远不够用，那估算下到底会占多少时间，平均每天几个小时。假如平均每天4个小时，那Ok，另外 4 个小时你做什么？你需要再找点儿事情来填满它，可以是赚钱的事情，也可以是兴趣、爱好、休闲，总之你如果有大把时间无事可干，就会出问题。 预期管理预期管理包括四个方面： 冷启动周期。像接项目、写书、在线课程，都有个回款周期，所以你应该设想一下，你可以承受的无收入的起始阶段有多长，并为此准备一些钱，比如你预计周期为 3 个月，那你就要准备上至少够 3 个月花的钱。 收入预期，最近三年，预期收入达到什么规模。 时间预期，准备做多久来验证自己真的可以持续走下去。 成就预期，你打算在哪个方向上取得什么成就、建立什么名声。 B和Z方案你要设想，万一你现在规划的事情，收入不如预期，不能保持你的生活水准，你还准备再做些什么？这就是你的 B 方案，你要有至少 2 种可以变现的事情。再设想一下最坏的情况：万一你无论如何都养不活自己，该怎么应对，是回单位上班？还是吃存款、继续硬撑？你一定要提前做好备案，这样才可以从容应对。 自由职业的自由与焦虑在这篇文章的开始部分，我们说“你需要更多的时间、金钱来扮演好丈夫（妻子）、父亲（母亲）、儿子（女儿）、女婿（媳妇）等各种角色”，因此你考虑自由职业。但是，真实的自由职业，可能并没有想象中那么美好，它有自由，也有不自由，有高收入，也有与自由和不确定性伴生的焦虑。 自由女儿看牙，时间约到周一下午，没关系，直接去了，不用请假。复诊，约到周五下午，没关系，直接去了，不用请假。朋友约见面聊天，周三中午，没关系，直接去了，不用请假，因为不用考虑上班的事情，聊到几点是几点。今天我累了，就晚点起来，没关系，不用担心上班迟到。今天晚上我有兴致，可以写作到凌晨2点，没关系，第二天不用上班。 你看，这就是自由职业最大的好处：拥有安排工作时间的自由。只要你完成任务解决问题，鬼才管你什么时间工作。然而，你的自由是建立在自律的基础上的，你的自由是如何安排自己工作的自由，而不是不工作想干什么就干什么的自由（那是财务自由）——因为你要赚钱养活自己。 举个例子，你答应了客户周四完成开发交付软件的第一个版本，结果你周一周二都有事情，代码没完成，可以把交付日期更改到下周一吗？不行！如果你在单位做事情，可以找上司说：“哎呀老板，出现了点状况，是这么这么回事儿，看来这个事情得延期一周才行……”也许这样老板就会答应，你就又有了时间。可是你自由职业后，没有老板啊，你得自己维护自己“值得被信任”的形象，得让你的雇主觉得你“靠谱”。所以，你承诺了就要做到，哪怕熬夜赶出来哇！ 这就是一种不自由。 焦虑上班最大的一个好处是：不用考虑你要做什么事情，不用考虑你做的事情能不能创造经济价值，不管怎样，你都每月固定拿薪水。只要你在单位待着，哪怕刷一天朋友圈，也有钱拿！这是多么大的幸福啊！可是自由职业者就不一样：不做事就没钱啊。而且，更尴尬的是，做事也不一定有钱啊。所以，自由职业者每天都会受到不确定性的干扰。譬如我，用了记账软件记录收支，每次看到一大片红色就焦虑，心里就琢磨，哎呀我的钱什么时候到账啊。要是看到这个月的支出已经远超收入，就焦虑得不行，哎呀，差这么多啊，下个月能不能补赚回来啊。 这是你对收入波动性的焦虑，尤其容易出现在刚刚成为自由职业者的时候。还有第二种焦虑：你做的事情是否能够持续。 现在，你知道了一切：开发者实现自由职业的 4 种常见方式，5 种必做准备，以及可能的自由和焦虑。你准备开始吗？ 本文摘选自知乎 程序员如何成为自由职业者]]></content>
      <categories>
        <category>职业</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
